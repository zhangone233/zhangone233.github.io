{"posts":[{"title":"CSS-媒体查询","text":"视口（viewport）当我们不加视口的时候，模拟移动端，body的宽度默认是980px,并不是手机屏幕的宽度，如果想要把页面在手机屏幕中显示完全，就会进行缩放，这样的话，里面的文字等就会看不清楚，为了避免这种情况，通常都会加视口，让页面的宽度等于手机屏幕的宽度。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 媒体查询@media 针对不同媒体类型可以定制不同的样式规则。 例如：你可以针对不同的媒体类型(包括显示器、便携设备、电视机，等等)设置不同的样式规则。 但是这些多媒体类型在很多设备上支持还不够友好。 @media not|only mediatype and (expressions) { CSS 代码…; } 媒体类型 all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕，平板电脑，智能手机等。 speech 应用于屏幕阅读器等发声设备 还有一些已经废弃的类型就不再列举了 媒体功能 aspect-ratio 定义输出设备中的页面可见区域宽度与高度的比率 color 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0 color-index 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0 device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的比率。 device-height 定义输出设备的屏幕可见高度。 device-width 定义输出设备的屏幕可见宽度。 grid 用来查询输出设备是否使用栅格或点阵。 height 定义输出设备中的页面可见区域高度。 max-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最大比率。 max-color 定义输出设备每一组彩色原件的最大个数。 max-color-index 定义在输出设备的彩色查询表中的最大条目数。 max-device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最大比率。 max-device-height 定义输出设备的屏幕可见的最大高度。 max-device-width 定义输出设备的屏幕最大可见宽度。 max-height 定义输出设备中的页面最大可见区域高度。 max-monochrome 定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。 max-resolution 定义设备的最大分辨率。 max-width 定义输出设备中的页面最大可见区域宽度。 min-aspect-ratio 定义输出设备中的页面可见区域宽度与高度的最小比率。 min-color 定义输出设备每一组彩色原件的最小个数。 min-color-index 定义在输出设备的彩色查询表中的最小条目数。 min-device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最小比率。 min-device-width 定义输出设备的屏幕最小可见宽度。 min-device-height 定义输出设备的屏幕的最小可见高度。 min-height 定义输出设备中的页面最小可见区域高度。 min-monochrome 定义在一个单色框架缓冲区中每像素包含的最小单色原件个数 min-resolution 定义设备的最小分辨率。 min-width 定义输出设备中的页面最小可见区域宽度。 monochrome 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0 orientation 定义输出设备中的页面可见区域高度是否大于或等于宽度。 resolution 定义设备的分辨率。如：96dpi, 300dpi, 118dpcm scan 定义电视类设备的扫描工序。 width 定义输出设备中的页面可见区域宽度。 直接上代码 媒体查询案例1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *{ margin:0;padding:0; } .box{ width:200px; height:200px; background:green; } /* 当屏幕的宽度小于600px的时候，我就让.box 这个盒子背景颜色pink */ @media screen and (max-width:600px){ .box{ background:pink; } } @media screen and (min-width:700px){ .box{ background:gold; } } /* 大于等300 小于等于800 */ @media screen and (min-width:300px) and (max-width:800){ } /* 需求：小于768px的时候显示一个颜色 大于768到1200 显示一个颜色 大于1200的时候显示一个颜色 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 媒体查询案例2 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *{ margin:0;padding:0; } .box{ width:200px; height:200px; background:green; } @media screen and (max-width:768px){ .box{ background:pink; } } @media screen and (min-width:769px) and (max-width:1200px){ .box{ background:gold; } } @media screen and (min-width:1201px){ .box{ background:darkseagreen; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- /* 需求：小于768px的时候显示一个颜色 大于768到1200 显示一个颜色 大于1200的时候显示一个颜色 */ --&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 媒体查询案例3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *{ margin:0; padding:0; } ul,ol{ list-style: none; } .box&gt;li{ width:12.5%; height:50px; text-align: center; line-height: 50px; border:1px solid lightgreen; float:left; box-sizing:border-box; } /* 大于等于1200 的时候显示8个 大于等于900 小于1200的时候显示4个 大于等于768px 小于900的时候显示2个 小于768px 的时候显示一个 */ @media screen and (min-width:1200px){ .box&gt;li{ width:12.5%; } } @media screen and (min-width:900px) and (max-width:1199px){ .box&gt;li{ width:25%; } } @media screen and (min-width:768px) and (max-width:899px){ .box&gt;li{ width:50%; } } @media screen and (max-width:767px){ .box&gt;li{ width:100%; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;box&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","link":"/posts/762ab198/"},{"title":"CSS3-flex布局","text":"1、 flex 布局的出现 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。 2、flex布局的兼容性问题注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 3、flex 布局的定义Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。flex 布局有两个值： display: flex; 代表的是块级 display: inline-flex; 代表的是行内块 下面的例子证明，display:flex; 的时候，两个div是上下排列的，但是如果是display：inline-flex; 的时候是左右排列的 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt; /* flex 布局有两个值： display:flex;代表的是块级 display:inline-flex;代表的是行内块 */ *{ margin:0; padding:0; } .box1{ width: 100px; height: 100px; background:green; display:inline-flex; } .box2{ width: 100px; height: 100px; background:pink; display:inline-flex; }&lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 4、flex 布局的基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点)叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 5、容器的属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 5.1 flex-direction属性:设置主轴的方向 row：主轴的方向是水平，从从左到右 column：主轴的方向是垂直的，从上到下 row-reverse：主轴的方向是水平，从右到左 column-reverse：主轴的方向是垂直的，从下到上 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt; *{ margin:0;padding:0; } ul,ol{ list-style: none; } ul{ display:flex; /* flex-direction: row; */ /* flex-direction: column; */ /* flex-direction: row-reverse; */ flex-direction: column-reverse; } ul&gt;li{ width:100px; height:100px; background:green; margin-left:10px; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 5.2 flex-wrap: wrap: 换行 nowrap: 不换行（默认） wrap-reverse：换行，不过第一行在最下面 5.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 flex-flow: row wrap; 写了这个之后，下面的案例效果跟上一个一样 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;flex-flow&lt;/title&gt;&lt;style&gt; * { margin:0; padding:0; } /* flex-flow 是flex-direction 和flex-wrap 的简写 */ ul,ol { list-style: none; } ul { display: flex; flex-flow: row wrap } ul&gt;li { width: 400px; height: 400px; background: green; margin-left: 10px; margin-bottom: 10px; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 5.4 justify-content属性定义了项目在主轴上的对齐方式。justify-content: flex-start | flex-end | center | space-between | space-around| space-evenly ; ​ space-evenly 5.5 align-items属性：align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 5.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。（也就是说得有项目换行）align-content: flex-start | flex-end | center | space-between | space-around | stretch; 6、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 6.1 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 6.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话)。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 123.item { flex-grow: &lt;number&gt;; /* default 0 */} 6.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 6.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} 6.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} flex：0 1 auto；默认值flex：none； 代表的意思等同于 flex：0 0 auto；flex：auto；代表的意思是flex：1 1 auto；flex：number；当flex取值为一个非负数字，则该数字为flex-grow的值，flex-shrink的值为1，flex-basis的值为0%； 6.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;}","link":"/posts/ca7f6989/"},{"title":"HTML5-CSS3-新属性","text":"1. 标签类1.1 map： 以前，我们要想点击某一张图片的时候，进行跳转，大家知道用a标签即可，但是如果我想让用户点击图片中的某一部分才能实现跳转，这个怎么实现呢？比如：只能点击就可以用map 结合area 来完成这个需求 &lt;map&gt;标签被用于定义客户端图像地图，即一个具有可点击区域的图像。map 的 name 属性和 id 用于定义图像地图的名称，它是&lt;map&gt;元素的必选属性(为了考虑浏览器兼容性，所以 id 和 name 我们都写)。通过将图像地图（&lt;map&gt;)的名称赋值给&lt;img&gt;的usemap属性，以在二者之间建立起联系。 1234&lt;img src=&quot;images/ball.jpg&quot; alt=&quot;&quot; usemap=&quot;ballMap&quot;&gt;&lt;map name=&quot;ballMap&quot; id=&quot;ballMap&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;142.5,142.5,142.5&quot; href=&quot;http://www.baidu.com&quot; alt=&quot;&quot;&gt;&lt;/map&gt; 1.2 area定义和用法 coords 属性规定区域的 x 和 y 坐标。 coords 属性与 shape 属性 配合使用，来规定区域的尺寸、形状和位置。图像左上角的坐标是 “0,0”。 详细解释： &lt;area&gt; 标签的 coords 属性定义了客户端图像映射中对鼠标敏感的区域的坐标。坐标的数字及其含义取决于 shape 属性中决定的区域形状。可以将客户端图像映射中的超链接区域定义为矩形、圆形或多边形等。下面列出了每种形状的适当值： 圆形：shape=&quot;circle&quot;，coords=&quot;x,y,z&quot; 这里的 x 和 y 定义了圆心的位置（”0,0” 是图像左上角的坐标），r 是以像素为单位的圆形半径。 多边形：shape=&quot;polygon&quot;，coords=&quot;x1,y1,x2,y2,x3,y3,...“ 每一对 “x,y” 坐标都定义了多边形的一个顶点（”0,0” 是图像左上角的坐标）。定义三角形至少需要三组坐标；高纬多边形则需要更多数量的顶点。多边形会自动封闭，因此在列表的结尾不需要重复第一个坐标来闭合整个区域。 矩形：shape=&quot;rectangle&quot;，coords=&quot;x1,y1,x2,y2&quot; 第一个坐标是矩形的一个角的顶点坐标，另一对坐标是对角的顶点坐标，”0,0” 是图像左上角的坐标。请注意，定义矩形实际上是定义带有四个顶点的多边形的一种简化方法。例如，下面的 XHTML 片段在一个 100x100 像素图像的右下方四分之一处，定义了一个对鼠标敏感的区域，并在图像的正中间定义了一个圆形区域。 1.3 datalistdatalist 标签定义可选数据的列表。与 input 元素配合使用，就可以制作出输入值的下拉列表。和select控件不一样的是，这个输入框除了可以选择选项外，我们还可以直接输入内容。不受选项的影响。所以当你的输入框需要提供一些选项给用户选择，但又不限制用户的输入内容时，不可以用这个datalist+input的组合来实现了。需要注意的是：1、datalist 和input需要配合使用（如果不写input 看不到效果）2、datalist 的id和input的list 属性相关联 123456&lt;input type=&quot;text&quot; list=&quot;luckyColor&quot; &gt;&lt;datalist id=&quot;luckyColor&quot;&gt; &lt;option value=&quot;pink&quot;&gt; &lt;option value=&quot;green&quot;&gt; &lt;option value=&quot;blue&quot;&gt;&lt;/datalist&gt; 1.4 svgsvg 是矢量图，放大缩小都不会失真。 1.4.1）画一个矩形x：矩形的起始x轴坐标y：矩形的起始y轴坐标rx：水平方向上的圆角弧度ry：垂直平方向上的圆角弧度width：矩形的宽度height：矩形的高度css样式stroke：边框的颜色css 样式stroke-width：边框的宽度css样式fill: 填充的颜色 123&lt;svg width=&quot;200&quot; height=&quot;200&quot; style=&quot;background-color: green;&quot;&gt; &lt;rect x=&quot;50&quot; y=&quot;50&quot; rx=&quot;10&quot; ry=&quot;50&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke:blue;stroke-width:5;fill:aquamarine&quot; &gt;&lt;/rect&gt;&lt;/svg&gt; 1.4.2）画一个椭圆 cx 、cy 圆点坐标 rx、ry x轴和y轴的半径123&lt;svg style=&quot;background:blue;&quot;&gt; &lt;ellipse cx=&quot;120&quot; cy=&quot;80&quot; rx=&quot;100&quot; ry=&quot;50&quot; style=&quot;stroke-width:5;fill:blue;stroke:pink;&quot;&gt;&lt;/ellipse&gt;&lt;/svg&gt; 1.4.3）圆如果上面的椭圆中的rx和ry值相等就是正圆 123&lt;svg style=&quot;background:blue;&quot;&gt; &lt;ellipse cx=&quot;120&quot; cy=&quot;80&quot; rx=&quot;50&quot; ry=&quot;50&quot; style=&quot;stroke-width:5;fill:blue;stroke:pink;&quot;&gt;&lt;/ellipse&gt;&lt;/svg&gt; 1.4.4)线条 x1、y1 折线的起点 x2、y2 折线的终点123456&lt;svg&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;100&quot; y2=&quot;100&quot; style=&quot;stroke:pink;stroke-width:5px;&quot;&gt; &lt;/line&gt;&lt;/svg&gt; 1.4.5）折线 points 里面是各个点的坐标，每个点的坐标用，进行分割123&lt;svg&gt; &lt;polyline points=&quot;0 0,100 100,300 100&quot; style=&quot;stroke:pink;stroke-width:5px;fill:#fff&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; 1.4.6)多边形 123&lt;svg&gt; &lt;polygon points=&quot;0 0,100 0,100 100, 0 100&quot; style=&quot;stroke:pink;stroke-width:1px;fill:#fff&quot;&gt;&lt;/polygon&gt;&lt;/svg&gt; 2. 渐变2.1 径向渐变语法： shape：形状 cricle 圆 ellipse 椭圆 size：尺寸（里面有两个值：x y） x轴的变径 y轴的半径 position：圆心的位置，默认是center 1radial-gradient:(shape size at position,color1,color2,....) 2.2 shape&amp;&amp;size椭圆形状，x轴的半径是100px y轴的半径是200px（也可以把定义的形状省去） 1background:radial-gradient(ellipse 100px 200px,red,green); 如果是circle 圆形，x轴和y轴的半径如果都写就会出错，因为既然定义了圆circle，就说明是圆了，x和y应该是相同的，所以以下是错误的，写一个值即可 1background:radial-gradient(circle 100px 100px,red,green); 正确 1background:radial-gradient(circle 100px,red,green); 如果记这些，觉得麻烦，我们可以不去写形状，因为定义的半径就决定了是圆还是椭圆 1234background:radial-gradient(100px 100px,red,green); // 圆background:radial-gradient(100px,red,green);// 圆background:radial-gradient(100px 200px,red,green); // 椭圆 2.3 size几个特殊的值： closest-side：指定径向渐变的半径为到最近边的距离 closest-corner：指定径向渐变的半径到最近的角的距离 fasest-side：指定径向渐变的半径为到最远边的距离 1background:radial-gradient(closest-side at 100px 100px,red,green); 1background:radial-gradient(farthest-side at 100px 100px,red,yellow); 1background:radial-gradient(farthest-corner at 0px 0px,red,yellow); 2.4 position默认圆心是在中心的位置 1background:radial-gradient(100px at center center,red,green); 圆心x轴方向在最右边，y轴方向在中心 1background:radial-gradient(100px at right center,red,green); 还可以是具体的像素值或者百分比 1background:radial-gradient(100px at 10px 10px,red,green); 3. clip-path MDN 定义：clip-path属性可以防止部分元素通过定义的剪切区域来显示，仅通过显示的特殊区域。剪切区域是被URL定义的路径代替行内或者外部svg，或者定义路线的方法例如circle().。clip-path属性代替了现在已经弃用的剪切 clip属性。 简单的说，就是自己可以画一个区域，超出此区域的部分隐藏 基本语法： &lt;clip-source&gt; | [ &lt;basic-shape&gt; || &lt;geometry-box&gt; ] | none属性说明&lt;clip-source&gt; = &lt;url&gt;&lt;basic-shape&gt; = &lt;inset()&gt; | &lt;circle()&gt; | &lt;ellipse()&gt; | &lt;polygon()&gt;&lt;geometry-box&gt; = &lt;shape-box&gt; | fill-box | stroke-box | view-box 3.1） 画一个矩形 inset()可以传入5个参数，分别对应top,right,bottom,left的裁剪位置,round radius（可选，圆角）示例clip-path: inset(2em 3em 2em 1em round 2em); 12345678.box{ width: 200px; height: 200px; background:aliceblue; border:1px solid red; clip-path: inset(30px 30px 30px 30px round 30px); background:url(&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=234380990,2754321816&amp;fm=26&amp;gp=0.jpg&quot;);} 3.2）圆criclecircle()可以传人2个可选参数；1. 圆的半径，默认元素宽高中短的那个为直径，支持百分比2. 圆心位置，默认为元素中心点 123.box2{ clip-path: circle(100px at center center);} 123.box2{ clip-path: circle(100px at right center);} 3.3) ellipse 椭圆ellipse()可以传人3个可选参数；1. 椭圆的X轴半径，默认是宽度的一半，支持百分比2. 椭圆的Y轴半径，默认是高度的一半，支持百分比3. 椭圆中心位置，默认是元素的中心点 123.box3{ clip-path: ellipse(100px 50px at center center);} 3.4) 多边形polygon这点的位置 123.box4{ clip-path:polygon(0 100px,100px 0,100px 100px) ;} 4. 变量写属性值var() 函数用于插入自定义的属性值，如果一个属性值在多处被使用，该方法就很有用。 1234567891011121314151617181920&lt;style&gt;:root{ --color:pink; --color2:blue;}.box{ width: 100px; height: 100px;}.box1{ background:var(--color);}.box2{ background:var(--color2);}&lt;/style&gt; 12&lt;div id=&quot;div1&quot; class=&quot;box box1&quot;&gt;box&lt;/div&gt;&lt;div id=&quot;div2&quot; class=&quot;box box2&quot;&gt;box&lt;/div&gt;","link":"/posts/cf29c013/"},{"title":"CSS两种经典布局","text":"简单了解一下CSS定位1. 定位：position static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 1.1 相对定位1234+ 没有脱离文档流，位置还在+ 层级高于普通文档流+ 给绝对定位的元素做参照物+ 相对自身 1.2 绝对定位12345678+ 脱离文档流+ 层级高于普通文档流的层级+ 绝对定位的元素在设置参照物的时候，必须是包含关系的上级元素+ 浏览器在寻找参照物的时候是按照就近原则进行查找，如果都没有设置，那它的参照物就是body+ 原本宽度可以继承，但是定位的元素，宽度不再继承了，是由自身内容决定的。如果是行内元素，定位之后，宽、高也可以起作用。+ 如果给绝对定位元素的宽度设置百分比的时候，那它是相对你参照物来说的，并不是父级。绝对定位的参照物：position：relative或者position:absolute、position:fixed ,只要是三者之一即可。 1.3 固定定位12+ 固定定位是相对于整个页面窗口的+ CSS3中可使用transfrom改变固定定位的参照元素 2. 如何利用定位position让一个元素在整个屏幕或者是一个盒子中水平垂直居中123456789101112131415161718让这个元素 position：absolute；+ left：50%； top：50%；+ margin-left: 负的盒子宽的一半；+ margin-top: 负的盒子高度的一半&lt;style&gt; .box{ width:200px; height:200px; background:green; position: absolute; left:50%; top:50%; margin-left:-100px; margin-top:-100px; }&lt;/style&gt; 3. 两种经典布局：3.1 圣杯布局：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } body { min-width: 600px; } .wrap { height: 500px; padding: 0 200px; box-sizing: border-box; } .wrap&gt;div { height: 100%; float: left; } .main { width: 100%; background-color: darkgreen; } .left { width: 200px; background-color: darkkhaki; margin-left: -100%; position: relative; left: -200px; top: 0; } .right { width: 200px; background-color: lightsalmon; margin-left: -200px; position: relative; left: 200px; top:0; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;main&quot;&gt;主体&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3.2 双飞翼布局:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } body { min-width: 600px; } .wrap { height: 500px; } .wrap div { height: 100%; } .wrap&gt;div { float: left; } .main { width: 100%; background-color: darkkhaki; padding: 0 200px; box-sizing: border-box; } .main&gt;.inner { background-color: darkseagreen; } .left { width: 200px; background-color: saddlebrown; margin-left: -100%; } .right { width: 200px; background-color: darkorange; margin-left: -200px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;inner&quot;&gt;inner&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","link":"/posts/a3150240/"},{"title":"ES6-Promise原理实现","text":"简单了解一下Promise在阮一峰大神的ES6入门文章中，关于对Promise的介绍： Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 回调地狱什么是 回调地狱（Callback Hell），它还有一个显得很霸气却极为令所有JS开发者感到无比厌烦的名字—— 厄运金字塔（Pyramid of doom）。之所以先了解这些，这是因为Promise本来就是为了避免在多重异步操作时产生深层次的嵌套回调提出的一种新型异步解决方案。 举个列子： 123456789101112131415function load (src,cb) { let es = document.createElement('script') es.src = src document.body.append(es) es.onload = () =&gt; { cb() } es.onerror = () =&gt; { cb(new Error('failed to load '+src )) }}load('./t1.js', err =&gt; { if(err === undefined) { f1(); // t1内部的函数 } else { console.log(err.message); }}) 上面的代码是很很常见的需求，随便添加一个js，然后执行里面的内容。 但是也会需要加载多个脚本，同时执行一些函数： 123456789101112131415161718192021load('./t1.js', err =&gt; { if(err === undefined) { f1(); // t1内部的函数 load('./t2.js', err =&gt; { if(err === undefined) { f2(); // t2内部的函数 load('./t3.js', err =&gt; { if(err === undefined) { f3(); // t3内部的函数 } else { console.log(err.message); } }) } else { console.log(err.message); } }) } else { console.log(err.message); }}) 这样的多重操作，会随着嵌套层数变深逐渐失控，于是便形成了臭名昭著的厄运金字塔。为了解决这个问题，于是Promise便应运而生——主要是将深层回调变成了链式调用，这样能更符合人类逻辑： 第一步：先让load返回一个Promise： 1234567891011// 每个 load 返回一个 Promise 对象// 每个Promise对象都有一个 then 方法。function load (src) { let es = document.createElement('script') es.src = src document.body.append(es) return new Promise((resolve, reject) =&gt; { es.onload = () =&gt; { resolve('success '+ src) } es.onerror = () =&gt; { reject(new Error('failed to load '+src )) } })} 第二步： 链式调用： 123456789101112131415161718load('./t1.js') .then(str =&gt; { console.log(str); f1(); return load('./t2.js') //这里返回一个Promise }) // 直接就能用 then .then(str =&gt; { console.log(str); f2(); return load('./t3.js') // 再返回一个Promise }) .then(str =&gt; { console.log(str); f3(); }) .catch(er =&gt; { console.log(er.message); }) 这样的代码看着就很舒服~ Promise极其重要的特征是链式调用，每个load函数返回一个Promise，该Promise在确定是异步加载成功还是失败之后就会被返回然后提供给下一个操作使用。 一个Promise队列就像是使用同步代码来实现异步操作一样。 引用 MDN 上的Promise概念： Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的Promise对象 1Javascript 中的 Promise 也参考了 Promise/A+ 规范。 ES6中的Promise原理实现Promise的用法就不多介绍了。可以去 MDN的官方文档 或者 阮一峰的ES6入门教程详情了解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Promise principle// 发布订阅class MyPromise { constructor(excutor) { this.PromiseStatus = &quot;pending&quot;; this.resolveEvent = []; this.rejectEvent = []; const resolve = (...arg) =&gt; { // Promise实例状态只能改变一次 if (this.PromiseStatus !== &quot;pending&quot;) return; this.PromiseStatus = &quot;fulfilled&quot;; clearTimeout(this.timer); this.timer = setTimeout(() =&gt; { this.resolveEvent.forEach(item =&gt; { typeof item === &quot;function&quot; ? item(arg) : void 0; }); }, 0); }; const reject = (...arg) =&gt; { if (this.PromiseStatus !== &quot;pending&quot;) return; this.PromiseStatus = &quot;rejected&quot;; clearTimeout(this.timer); this.timer = setTimeout(() =&gt; { this.rejectEvent.forEach(item =&gt; { typeof item === &quot;function&quot; ? item(arg) : void 0; }); }); }; // 如果用function定义的resolve/reject, 可以用bind定向一下this指向 try { excutor(resolve, reject); } catch (e) { reject(e); } } // prototype then(resolveFn, rejectFn) { if (typeof resolveFn !== &quot;function&quot;) { resolveFn = Function.prototype; } if (typeof rejectFn !== &quot;function&quot;) { rejectFn = Function.prototype; } // 链式调用then，默认返回的是一个成功态的Promise实列 // 如果上一个then其回调执行返回的是Promise实列，那么默认返回的状态受到其影响 return new MyPromise((resolve, reject) =&gt; { this.resolveEvent.push((arg) =&gt; { // push 一个匿名箭头函数，异步执行的是这个匿名函数、 // 通过上级作用域查找到then的回调让其执行，判断其返回值 const result = resolveFn(...arg); result instanceof MyPromise ? result.then(resolve, reject) : resolve(); }); this.rejectEvent.push((arg) =&gt; { const result = rejectFn(...arg); result instanceof MyPromise ? result.then(resolve, reject) : resolve(); }); }); }} 一个简易版的Promise实现了，Promise原型上的方法还有好几个，这里只简单实现了最常用的 then 1234567891011121314151617181920212223let mp1 = new MyPromise((resolve, reject) =&gt; { console.log(&quot;Promise callback&quot;); resolve(&quot;resolve ok&quot;); // reject(&quot;reject not&quot;);});mp1.then(str =&gt; { console.log(str); return new MyPromise((resolve, reject) =&gt; { reject(); });}, str =&gt; { console.log(str);}).then(str =&gt; { // 如果上一个then回调执行时没有返回一个Promise实例，那么会默认返回一个成功态的Promise实列 console.log(str); // undefined}, () =&gt; { console.log(&quot;rejected callback 2&quot;); // 默认成功态，这里的rejected回调不会执行}).then(() =&gt; { console.log(&quot;resolve callback 3&quot;); // 执行});console.log(&quot;synchronization&quot;); 试了几下，完美实现~ 嗝 ~~","link":"/posts/dfe13b31/"},{"title":"ES6-Proxy","text":"在即将到来的Vue3.0中，Vue数据的响应式系统采用了ES6的Proxy来代替Object.defineProperty Object.defineProperty ：兼容主流浏览器和ie9以上的ie浏览器，能够监听数据对象的变化，但是监听不到对象属性的增删、数组元素和长度的变化，同时会在vue初始化的时候把所有的Observer都建立好，才能观察到数据对象属性的变化。 Proxy : 可以做到监听对象属性的增删和数组元素和长度的修改，还可以监听Map、Set、WeakSet、WeakMap，同时还实现了惰性的监听，不会在初始化的时候创建所有的Observer，而是会在用到的时候才去监听。 Proxy语法：Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 1const p = new Proxy(target, handler) 参数： target : 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。 Proxy – api: 12Proxy.revocable()// 创建一个可撤销的Proxy对象。 handler 对象的方法 对象是一个容纳一批特定属性的占位符对象。它包含有 Proxy 的各个捕获器（trap）。 所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。 12345678910111213141516171819202122232425262728293031323334353637383940// Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)： // 拦截对象属性的读取， 比如proxy.foo和proxy['foo']。 set(target, propKey, value, receiver)： // 拦截对象属性的设置， 比如proxy.foo = v或proxy['foo'] = v， 返回一个布尔值。 has(target, propKey)： // 拦截propKey in proxy的操作， 返回一个布尔值。 deleteProperty(target, propKey)： // 拦截delete proxy[propKey] 的操作， 返回一个布尔值。 ownKeys(target):// 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)： // 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)： // 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)： // 拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)： // 拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)： // 拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)： // 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)： // 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 construct(target, args)：// 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 关于 Refect Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API Reflect与Proxy--handler对象的方法是一一对应的; 关于Reflect的详情了解 点击了解ES6 =&gt; Reflect get() 与 set() get=&gt; 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。 set =&gt; 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。 12345678910111213141516171819202122232425262728293031323334353637// new Proxy(target, handler);// target ==&gt; 要进行拦截的对象// handler ==&gt; 要求是一个对象，用于定制拦截的行为，及逻辑处理// 如果handler是一个空对象，就不会有任何的拦截处理，访问 py 这个实例效果同于访问 target。let obj = { name: &quot;Proxy&quot;,};let py = new Proxy(obj, { get(target, key, example) { // target =&gt; obj:{name:&quot;Proxy&quot;} // key =&gt; 每次要获取的属性名 propKey // example =&gt; 当前 py 这个实例 return Reflect.get(target, key); // return &quot;default&quot;; 每次都会获取到固定返回值 }, set(target, key, newValue, example) { // console.log(target, key, value, example); // newValue =&gt; 将要设置的新值 if (Reflect.get(target, key) !== newValue) { Reflect.set(target, key, newValue); } }});// getconsole.log(py.name); //=&gt; &quot;Proxy&quot;console.log(py.age); //=&gt; undefined// setpy.age = &quot;20&quot;;py.name = &quot;newProxy&quot;;console.log(py);console.log(obj); Proxy 实例也可以作为其他对象的原型对象。1234567891011121314let py = new Proxy({}, { get(target, key, example) { // if (key === &quot;__proto__&quot;) return example; return &quot;default&quot;; }, set(target, key, newValue) { Reflect.set(target, key, newValue); }});let obj = Object.create(py);console.log(obj.df); //=&gt; &quot;default&quot;console.log(obj.__proto__); //=&gt; &quot;default&quot;console.log(obj.prototype); //=&gt; &quot;default&quot; 阮一峰ES6-Proxy 文档中，使用get拦截，实现数组读取负数的索引 123456789101112131415161718function createArray(...elements) { let handler = { get(target, propKey, receiver) { let index = Number(propKey); if (index &lt; 0) { propKey = String(target.length + index); } return Reflect.get(target, propKey, receiver); } }; let target = []; target.push(...elements); return new Proxy(target, handler);}let arr = createArray('a', 'b', 'c');arr[-1] // ==&gt; c 上面代码中，数组的位置参数是-1，就会输出数组的倒数第一个成员。 利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。 12345678910111213141516171819202122var pipe = function (value) { var funcStack = []; var oproxy = new Proxy({}, { get: function (pipeObject, fnName) { if (fnName === 'get') { return funcStack.reduce(function (val, fn) { return fn(val); },value); } funcStack.push(window[fnName]); return oproxy; } }); return oproxy;}var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;pipe(3).double.pow.reverseInt.get; // ==&gt; 63 上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。 实例：使用 Proxy 实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 12345678910111213const person = observable({ name: '张三', age: 20});function print() { console.log(`${person.name}, ${person.age}`)}observe(print);person.name = '李四';// 输出// 李四, 20 上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 12345678910const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, {set});function set(target, key, value, receiver) { const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;} 上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。 了解更多的实例介绍，和其他拦截操作的方法介绍 =&gt; ES6-Proxy","link":"/posts/adb531e4/"},{"title":"Git-一些命令","text":"2022年来个更新： 发现一个不错的Git常用命令中文教程网站：https://tsejx.github.io/devops-guidebook/code/git Git 随笔记录一些命令 常用步骤操作git init : 让本地的文件夹初始化成一个git仓库；git status : 查看这个文件中文件的状态；红色：文件在开发区 绿色：开发区和暂存区的代码一致；git add : 把开发区的代码克隆一份上传到暂存区；git checkout -- 文件名 : 把暂存区存储的代码把本地给覆盖掉；git restore 文件名 : 【也是将暂存区的文件覆盖本地】git rm --cached 文件名： 删除在暂存区的文件git commit -m“提交注释” : 将暂存区的代码上传到历史区； 一个本地仓库可以连接多个远程仓库git remote add origin 远程仓库地址；git remote -v : 查看本地仓库和远程仓库的连接；git clone: 远程仓库地址：把远程仓库下载到自己电脑上git pull origin master : 拉取最新的代码； 如果是第一次使用git，需要将代码从暂存区上传到历史区，需要配置全局的邮箱和用户名；在git Bash Here中执行下面两条命令git config --global user.email &quot;你的邮箱&quot;git config --global user.name &quot;用户名&quot;git commit -m&quot;xxx&quot; 初始化配置配置使用git仓库的人员姓名git config --global user.name &quot;Your Name Comes Here&quot; 配置使用git仓库的人员emailgit config --global user.email you@yourdomain.example.com 配置到缓存 默认15分钟git config --global credential.helper cache 修改缓存时间git config --global credential.helper 'cache --timeout=3600' 配置别名git config --global color.ui true git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch 设置Editor使用textmategit config --global core.editor &quot;mate -w&quot;git config -1 # 列举所有配置 打开用户的git配置文件~/.gitconfig 查看、添加、提交、删除、找回，重置修改文件git help # 显示command的helpgit show # 显示某次提交的内容git show $id git co -- # 抛弃工作区修改git co . # 抛弃工作区修改git add # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm # 从版本库中删除文件git rm --cached # 从版本库中删除文件，但不删除文件git reset # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git cigit ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am &quot;some comments&quot; git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff # 比较当前文件和暂存区文件差异git diff git diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异git diff .. # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录git loggit log # 查看该文件每次提交记录git log -p # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息 Tips :Mac上可以使用 tig 代替 diff 和 log 1brew install tig 取得Git仓库cd到放置所在目录 1cd &lt;$directory&gt; Clone远程版本库git clone git@xbc.me:wordpress.git 添加远程版本库origin，语法为 git remote add [shortname] [url] git remote add origin git@xbc.me:wordpress.git 查看远程仓库git remote -v 提交你的修改添加当前修改的文件到暂存区git add . 如果你自动追踪文件，包括你已经手动删除的，状态为 Deleted 的文件git add -u 提交你的修改git commit –m &quot;你的注释&quot; 推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支] git push origin master 查看文件状态git status 跟踪新文件git add readme.txt 从当前跟踪列表移除文件，并完全删除git rm readme.txt 仅在暂存区删除，保留文件在当前目录，不再跟踪git rm –cached readme.txt 重命名文件git mv reademe.txt readme 查看提交的历史记录git log 修改最后一次提交注释的，利用–amend参数git commit --amend 忘记提交某些修改，下面的三条命令只会得到一个提交。git commit –m &quot;add readme.txt&quot; git add readme_forgotten git commit –amend 假设你已经使用git add .，将修改过的文件a、b加到暂存区现在你只想提交a文件，不想提交b文件，应该这样git reset HEAD b 取消对文件的修改git checkout –- readme.txt 查看、切换、创建和删除分支 branchgit br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d # 删除某个分支git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master # 将master rebase到branch，相当于：git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d )，然后再push 删除远程分支基本的分支管理创建一个分支git branch dev 切换工作目录到devgit chekcout dev 将上面的命令合在一起，创建dev分支并切换到dev git chekcout –b dev 合并dev分支，当前工作目录为master git merge dev合并完成后，没有出现冲突，删除dev分支git branch –d dev 拉去远程仓库的数据，语法为 git fetch [remote-name]git fetchfetch 会拉去最新的远程仓库数据，但不会自动到当前目录下，要自动合并git pull 查看远程仓库的信息git remote show origin 建立本地的dev分支追踪远程仓库的develop分支git checkout –b dev origin/develop Git远程仓库管理git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库git branch --set-upstream master origin/master git branch --set-upstream develop origin/develop 嗝~~ 睡了睡了 git sleep ~`","link":"/posts/b48aecb5/"},{"title":"ES6-Reflect","text":"简单了解Reflect12console.log(new Reflect); // Error ==&gt; Reflect is not a constructor// =&gt; 虽然是大写开头，但不是一个类，不可以被new； 概述： 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。123456789let obj = { a: 1, b: 2};&quot;a&quot; in obj // =&gt; true 之前的旧语法，用关键字 in 判断某个属性是否属于某个对象Reflect.has(obj, &quot;a&quot;); // =&gt; true Reflect.has(); 函数形式的新语法，作用等同于上// 列如：还有像删除属性的关键字 delete obj[key] ==&gt; Reflect.deleteProperty(obj,key); Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 简单粗暴：直接打印它12345678910111213141516171819console.log(Reflect); // 省张图片，控制台结果粘过来{defineProperty: ƒ, deleteProperty: ƒ, apply: ƒ, construct: ƒ, get: ƒ, …}apply: ƒ apply()construct: ƒ construct()defineProperty: ƒ defineProperty()deleteProperty: ƒ deleteProperty()get: ƒ ()getOwnPropertyDescriptor: ƒ getOwnPropertyDescriptor()getPrototypeOf: ƒ getPrototypeOf()has: ƒ has()isExtensible: ƒ isExtensible()ownKeys: ƒ ownKeys()preventExtensions: ƒ preventExtensions()set: ƒ ()setPrototypeOf: ƒ setPrototypeOf()__proto__: Object... Reflect对象目前一共有 13 个静态方法1234567891011121314151617181920212223242526272829303132333435363738Reflect.apply(target, thisArg, args) //=&gt; Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。Reflect.construct(target, args) //=&gt; 以 new 方式去执行一个构造函数 new Fn() ==&gt; Reflect.construct(Fn,实参)Reflect.get(target, name, receiver) //=&gt; 获取对象的某个属性的值 ==&gt; obj.keyReflect.set(target, name, value, receiver) //=&gt; 设置对象的某个属性的值 ==&gt; obj.key = &quot;new value&quot;Reflect.defineProperty(target, name, desc) // =&gt; Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。Reflect.deleteProperty(target, name) // =&gt; Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。Reflect.has(target, name) // =&gt; Reflect.has方法对应name in obj里面的in运算符。Reflect.ownKeys(target) // =&gt; Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。Reflect.isExtensible(target) // =&gt; Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。Reflect.preventExtensions(target) // =&gt; Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。Reflect.getOwnPropertyDescriptor(target, name) // =&gt; Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。Reflect.getPrototypeOf(target) // =&gt; Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。Reflect.setPrototypeOf(target, prototype) // =&gt; Reflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。 上面这些方法的作用， 大部分与Object对象的同名方法的作用都是相同的， 而且它与Proxy对象的方法是一一对应的。 未来Object上的一些方法，还有其他一些对象的操作语法，都会进行规范式的处理，有的可能会稍微改动。 并且会逐渐废弃Object上的某些方法，但会转移到新的 Reflect 这个对象上面。 更加详情了解–ES6-Reflect","link":"/posts/7db6df7e/"},{"title":"HTML4-HTML5新增标签","text":"至HTML4.01 一些标签 p 标签 h1-h6标题 a 超链接 img 图片 div 大盒子标签 span 小盒子标签 strong / b 加粗 i / em 斜体 del 删除线 small 小 big 大 预格式化 : pre 列表： 无序列表 ul li 有序列表 ol li 自定义列表 dl dt dd table 表格 ： caption 表格的标题 tr td th thead tbody tfoot label input: type 类型 text 文本输入框 password 密码 button（: value=“支付”） submit 提交 reset 重置 radio 单选 checkbox 多选 button 按钮 textarea 文本域 select 下拉框 form 表单 HTML5 新增的一些标签 video 视频 audio 音频 header 页面头部 footer 页面底部 main 页面主内容 aside 页面侧区域 section 布局模块，类似div nav 导航 figure figcaption article 文章 input : type 类型 number 数字 tel 电话号码 search 搜索 email 邮箱 color 颜色拾取器 range 范围 file 上传文件 date 日期 标签的划分 块级元素 独占一行 可以设置宽和高 排列方式：从上到下 行内块 可以共占一行 设置宽和高起作用 排列方式：从左到右 行内元素 可以共占一行 写宽高不起作用 排列方式从左到右 简单划分一下 块级：p h1-h6 div 列表 表格 header footer main aside nav figure figcaption、article、pre ..... 行内块元素 img button input textarea video audio select ... 行内元素 a span label b strong i em del big small ...","link":"/posts/40c3e27/"},{"title":"JS-ES3-ES5-经典三种设计模式","text":"JS中的单例设计模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 在没有对象和函数等引用数据类型的时候，我们只能基于创建变量的方式来描述某一件事务，某一个个体的相关信息 // 这样会大量创建全局变量，最后导致全局变量的冲突（全局变量污染）var name = &quot;张三&quot;;var age = 25;var height = &quot;180cm&quot;;var name = &quot;李四&quot;;var age = 28;var height = &quot;175cm&quot;;// 我们期望能够把描述一个事务的相关信息能够分组（或分类）来管理，此时对象数据类型就起到了很大的作用// 分组之后，每一组中的键值对都是私有的，即使两组之间有相同名字的属性，也不会冲突，大大解决了全局变量污染的问题 =&gt; “这种分组管理的概念，就是JS中最早的单例设计模式思想”var person1 = { name:'张三', age:25, ...};var person2 = { name:'李四', age:28, ...};/* * 基于对象数据类型，把描述当前事务的属性和方法统一放在一起分组管理，能够减少全局变量污染，这种JS设计模式就是“单例设计模式” * 1. 每一个对象都是一个单独的实例（单独的堆内存），存储的键值对都是堆中私有的内容，所以两个实例之间不会有任何的冲突 * 2. 在单例设计模式中，有一些新的概念，在下述案例中：obj不仅仅是一个变量存储对象（对象名），也被成为“命名空间”（其实就是给对象的堆内存设置一个obj的名字，堆内存是空间，obj是名字），把描述当前事务的属性和方法，放到空间中进行分组管理 * var obj = { xxx:xxx , ...}; * * 在其它的编程语言中，认为只有基于构造函数构造出来的实例才能被称为“单例设计模式”，也就是 var xxx = new xxx; 但是在JS中，var obj={...}; 本身就是基于 new Object() 构建出来的，所以是标准的单例设计模式； */// + 单例设计模式也是最基础的模块化思想// + AMD/CMD（requireJS和seaJS）// + UMD// + CommonJS// + ES6Module// 基于单例设计模式思想 + 闭包思想 + 模块管理思想 (高级单例模式)var utils = (function(){ function queryElement(){} function deleteElement(){} ... // 导出当前版块中需要供别人调取的属性方法（也相当于把这些属性方法放到utils命名空间下进行分组管理，避免和别人的冲突） return { queryElement:queryElement, deleteElement:deleteElement };})();var searchModule = (function(){ function queryData(){} function bindHTML(){ //=&gt;需要调取utils模块（命名空间中的方法） utils.queryElement(); } return { init:function(){ } };})(); 工厂设计模式123456789101112131415161718192021222324252627282930313233343536373839404142// 基于 “单例设计模式” 记录人员信息：创建单独的实例或者命名空间，把描述每个人的信息分组管理即可实现// 缺陷：每当描述一个事务的信息，需要把对应的键值对都去编写一下，如果重复描述相似事务的信息，不仅需要重复做很多事情，而且还会导致代码的冗余.var person1 = { name:'张三', age:92, sex:'男', score:90};var person2 = { name:'李四', age:62, sex:'男', score:85};var person3 = { name:'王二', age:18, sex:'女', score:100， qunzi:'red'};// 所谓工厂设计模式，是在需要创建很多“相似实例”的情境下，让我们告别手动创建，而实现工业化批量生产（提高开发效率、减少了页面中的冗余代码 =&gt; “低耦合高内聚” =&gt; 函数封装）function createPerson(name, age, sex, score, qunzi) { var person = {}; person.name = name; person.age = age; person.sex = sex; person.score = score; if(typeof qunzi !== &quot;undefined&quot;) { // 传递了qunzi 形参对应的实参值 person.qunzi = qunzi; } return person;}var person1 = createPerson('张三',92,'男',90);var person2 = createPerson('李四',62,'男',85);var person3 = createPerson('王二',18,'女',100,'red'); 面向对象 编程语言： OOP（Object Oriented Programming）面向对象程序设计 JAVA PHP PYTHON / GO / RUBY JAVASCRIPT / NODE.JS … POP（Procedure Oriented） 面向过程程序设计 C语言 面向对象程序设计中的三大概念： 对象：泛指，JS中我们操作和研究的事务都是对象 类：把抽象的对象，按照功能特点，进行的详细划分，划分成为很多的类别 实例：每一种类别中具体的事务 JS中内置类 根据JS中事务的特征，进行类别划分，而默认划分好的类别，就是内置类 数据类型中的内置类 Number类：每一个数字都是这个类的一个实例 String 类 Boolean 类 Null 类 / Undefined 类（浏览器中进制我们自己访问这两个类） Symbol 类 Object 对象数据类型类：所有的对象数据类型都是这个类的一个实例 Object {}普通对象就是它的实例 Array 数组类 每一个数组是Array类的实例也是Object类的实例 RegExp正则类 Date日期类 … Function类：所有的函数都是这个类的实例 … 其它 DOM元素对象或者DOM元素集合也都有自己的内置类 … Node 节点类 Element 元素标签类 HTMLElement HTML元素标签类 HTMLDivElement 每一个DIV元素对象是它的一个实例 HTMLAnchorElement 每个A元素对象是它的一个实例 每一个元素标签对象都有一个自己对应的内置类 XMLElement … Text 文本节点类 Document 文档节点类 HTMLDocument 每一个document都是它的一个实例 … HTMLCollection 元素集合类：基于getElementsByTagName等方法获取到的元素集合都是它的一个实例 NodeList 节点集合类 … JS本身就是按照“面向对象思想（类和实例）”设计出来的语言，所以不论是研究或是学习JS，还是在工作中进行开发，也都应该按照面向对象的思想来学习和开发，例如： 123456789101112131415161718192021/* 我想研究数组 */// 1.每一个数组都是Array这个类的实例，每个实例都是单独的一个个体（互相是不冲突的，类似于没有一模一样的两个人，在JS中也基本上没有完全一样的两个实例[会有特殊情况]）// 2.我们拿出某一个实例去分析其特点和结构，那么Array的其它实例也具备相同的特点和结构// 3.数组中有很多浏览器内置的方法，这些方法都是类提供给实例的，每一个实例都能具备和使用这些方法（前提是当前类的实例才能使用，如果不是它的实例，则不能使用）let arr1 = [12,23];let arr2 = [12,23];console.log(arr1 === arr2); // false 不同的堆内存地址// push 是 Array 这个类提供的方法，只要是 Array 类的实例（数组是它的实例）都可以调用这些方法let arr = [10, 20];arr.push(30);console.log(arr); //=&gt;[10,20,30]// arguments 不是 Array 的实例，不能调它提供的方法function func() { // arguments 实参集合中存储了传递的实参信息，它是一个类数组（类似于数组的结构，但是它不是数组，不是Array类的实例） arguments.push(30); // Uncaught TypeError: arguments.push is not a function console.log(arguments);}func(10, 20); 构造函数模式：基于构造函数，创建自定义类和创建类的相关实例1234567891011121314151617181920212223242526// 约定规范：类名的第一个字母一般都是大写的// 1.构造函数执行，由于具备普通函数特征，所以在私有上下文中可能会出现一些私有变量，但是这些私有变量和实例没有必然的联系，私有上下文中的 this 才是实例，所以只有写 this.xxx = xxx 的操作，才是给实例设置私有属性； 实例的私有属性和上下文中的私有变量不是一个东西// 2. 当前类的每一个实例都是单独的一个对象，实例和实例之间是独立的// 3. 在构造函数的函数体中，基于 this.xxx = xxx 给实例设置的属性和方法都是自己私有的，和其它实例中的属性和方法不冲突function Fn(x) { let y = 20; this.total = x + y; this.say = function () { console.log(`${x} + ${y} = ${this.total}`); };}let f1 = Fn(10); // f1=undefinedlet f2 = new Fn(10); // f2实例对象let f3 = new Fn(20); // f3实例对象console.log(f2.total); // 30console.log(f2.x); // undefinedconsole.log(f3.y); // undefinedconsole.log(f1 === f2); // falseconsole.log(f2 === f3); // falsef2.say(); // &quot;10+20=30&quot;console.log(f2.say === f3.say); // false 都是当前实例的私有属性和方法（所有出现在构造函数的函数体中的 this.xxx = xxx 操作，都是设置私有的属性和方法）console.log(f1.total); // Uncaught TypeError: Cannot read property 'total' of undefined f1不是对象，只有对象才能操作键值对console.log(window.total); // 30window.say(); // &quot;10 + 20 = 30&quot; 每一个函数都内置具备一个属性：prototype（原型），prototype的属性值是一个对象（浏览器默认会给其一个堆内存） =&gt; “原型对象上所存储的属性和方法，就是供当前类实例所调用的公有的属性和方法” 普通函数 类也是函数类型的值 在类的prototype原型对象中，默认存在一个内置的属性：constructor（构造函数），属性值就是当前类(函数)本身，所以我们也把类称为构造函数 每一个对象都天生具备一个属性：__proto__（原型链指向），属性值是当前实例（对象）所属类的prototype原型 对象数据类型值 普通对象 数组对象 正则对象 … 实例也是对象类型值（除基本值外） 类的prototype原型属性值也是对象 函数也具备对象的特征（它有一重身份就是对象类型） … 所有的对象数据类型值，都是内置类Object的一个实例 了解ES6-Class ==&gt; 阮一峰ES6教程–关于 Class定义类","link":"/posts/baa6c12d/"},{"title":"JS-深浅拷贝","text":"JS中数据类型的简单介绍在JS中，数据类型分为基本数据类型和引用数据类型两种，对于基本数据类型来说，它的值直接存储在栈内存中，而对于引用类型来说，它在栈内存中仅仅存储了一个引用，而真正的数据存储在堆内存中 当我们对数据进行操作的时候，会发生两种情况 基本数据类型： 12345let a = 3;let b = a;b = 5console.log(a); // 3console.log(b); // 5 可以直观的看到对于基本数据类型来说，变量 a 和变量 b 各自为值，变量 b 的值改变不会影响变量 a 的值。 引用数据类型 : 123456789var obj1 = { a: 1, b: 2, c: 3}var obj2 = obj1;obj2.a = 5;console.log(obj1.a); // 5console.log(obj2.a); // 5 可以看到的是，两个对象的值全部被修改了 对象是引用类型的值，对于引用类型来说，我们将 obj1 赋予 obj2 的时候，我们其实仅仅只是将 obj1 存储在栈堆中的的引用赋予了 obj2 ，而两个对象此时指向的是在堆内存中的同一个数据，所以当我们修改任意一个值的时候，修改的都是堆内存中的数据，而不是引用，所以只要修改了，同样引用的对象的值也自然而然的发生了改变 上面的两个例子只是正常的赋值操作 浅拷贝 仅仅是复制了对象中最外层键值对，对于深层次的属性，如果存储的值是也是引用类型的, 彼此之间修改的操作会互相影响 实现浅拷贝的方法有多种，例如： 数组的浅拷贝：Array.slice 12345678let log = console.log;let ary = [1, [2, [3]]];let newAry = ary.slice();newAry[0] = &quot;A&quot;; // 更改第一层的数组成员newAry[1][0] = &quot;B&quot;; // 更改第二层的成员log(ary); // [1,[&quot;B&quot;,[3]]]log(newAry); // [&quot;A&quot;,[&quot;B&quot;,[3]]] 对象的浅拷贝：Object.assign 1234567let obj = {name:&quot;AA&quot;,child:{name:&quot;BB&quot;,child:{name: &quot;CC&quot;}}};let newObj = Object.assign({}, obj);newObj.name = &quot;DD&quot;;newObj.child.name = &quot;EE&quot;log(obj); // {name:&quot;AA&quot;,child:{name:&quot;EE&quot;,child:{name:&quot;CC&quot;}}}log(newObj); // {name:&quot;DD&quot;,child:{name:&quot;EE&quot;,child:{name:&quot;CC&quot;}}} 深拷贝在实际的开发中，肯定不能让每个对象的值都指向同一个堆内存，这样的话不便于我们做操作，所以自然而然的诞生了深拷贝 深拷贝作用在引用类型上！例如：Object，Array深拷贝不会拷贝引用类型的引用，而是将引用类型的值全部拷贝一份，形成一个新的引用类型，这样就不会发生引用错乱的问题，使得我们可以多次使用同样的数据，而不用担心数据之间会起冲突 先看一下利用JSON对象中的方法来实现的深拷贝： JSON.stringify()以及JSON.parse() 12345678let obj = {name:&quot;AA&quot;,child:{name:&quot;BB&quot;,child:{name: &quot;CC&quot;}}}; let deepObj = JSON.parse(JSON.stringify(obj)); deepObj.name = &quot;DD&quot;; deepObj.child.child.name = &quot;XX&quot;; log(obj); // {name:&quot;AA&quot;,child:{name:&quot;BB&quot;,child:{name:&quot;CC&quot;}}} log(deepObj); // {name:&quot;DD&quot;,child:{name:&quot;BB&quot;,child:{name:&quot;XX&quot;}}} 可以看到没有发生引用问题，修改deepObj的数据，并不会对obj造成任何影响但是使用JSON.stringify()以及JSON.parse()它是不可以拷贝 undefined、 function、RegExp等等类型的；且对于Date实例在拷贝后的新对象中自动把实例对象转成了字符串 写一个深拷贝的方法，利用函数递归来解决深拷贝 12345678910111213141516171819202122232425262728293031let obj = [ {name: &quot;AA&quot;, age: undefined, arr: [{reg: /^\\d+$/g}]}, {name: &quot;BB&quot;, age: function(){}, arr: [{time: new Date()}]}, {count: 666}, 1, 2, 3];function deepClone(target) { let result; let targetType = {}.toString.call(target); if (targetType === &quot;[object Object]&quot; || targetType === &quot;[object Array]&quot;) { targetType = Array.isArray(target); result = targetType ? [] : {}; for (let key in target) { targetType ? result.push(deepClone(target[key])) : (result[key] = deepClone(target[key])); } } else { result = target; } return result;}let deepObj = deepClone(obj);console.log(obj);console.log(&quot;------------------------&quot;);console.log(deepObj); 控制台看下效果： 修改下数据试一试 123deepObj[0].name = &quot;CC&quot;;deepObj[1].age = null;deepObj[2].count = 888; 感觉还行，可以看到最终拷贝的结果是null、undefinde、function、RegExp等特殊的值也全部拷贝成功了，而且修改里边的值也不会有任何问题的 到这里就实现了一个简单的深拷贝，当然，我也只是简单实现一下，还有很多问题没有解决，只是一个思路 嗝~","link":"/posts/474f02db/"},{"title":"JS-函数防抖(debounce)和节流(throttling)","text":"防抖（debounce）和 节流（throttling） 防抖和节流出现的原因 防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。 …. 实现防抖 防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。 123456789101112131415161718192021222324/* * debounce:函数防抖 * @params * func:要执行的函数 * wait:间隔等待时间 * immediate:在开始边界还是结束边界触发执行(true =&gt; 在开始边界) * @return * 可被调用的函数 */ function debounce(func, wait, immediate) { let result = null, timeout = null; return function (...args) { let context = this, now = immediate &amp;&amp; !timeout; clearTimeout(timeout); // 重要：在设置新的定时器之前，我们要把之前设置的定时器都干掉，因为防抖的目的是等待时间内，只执行一次 timeout = setTimeout(() =&gt; { timeout = null; if (!immediate) result = func.call(context, ...args); }, wait); if (now) result = func.call(context, ...args); return result; } } 实现节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。 1234567891011121314151617181920212223242526272829303132/* * throttle：函数节流是为了缩减执行频率，当达到了一定的时间间隔就会执行一次 * @params * func:需要执行的函数 * wait:设置的间隔时间 * @return * 返回可被调用的函数*/ let throttle = function (func, wait) { let timeout = null, result = null, previous = 0; // 上次执行时间点 return function (...args) { let now = new Date, context = this; // remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间间隔 let remaining = wait - (now - previous); if (remaining &lt;= 0) { clearTimeout(timeout); previous = now; timeout = null; result = func.apply(context, args); } else if (!timeout) { timeout = setTimeout(() =&gt; { previous = new Date; timeout = null; result = func.apply(context, args); }, remaining); } return result; }; };","link":"/posts/fd252af5/"},{"title":"JS-发布订阅模式","text":"了解设计模式 背景 设计模式并非是软件开发的专业术语，实际上，“模式”最早诞生于建筑学。 设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。通俗一点说，设计模式是在某种场合下对某个问题的一种解决方案。如果再通俗一点说，设计模式就是给面向对象软件开发中的一些好的设计取个名字。 这些“好的设计”并不是谁发明的，而是早已存在于软件开发中。一个稍有经验的程序员也许在不知不觉中数次使用过这些设计模式。GoF（Gang of Four–四人组，《设计模式》几位作者）最大的功绩是把这些“好的设计”从浩瀚的面向对象世界中挑选出来，并且给予它们一个好听又好记的名字。 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案，他不是一个死的机制，他是一种思想，一种写代码的形式。每种语言对于各种设计模式都有他们自己的实现方式，对于某些设计模式来说，可能在某些语言下并不适用，比如工厂方法模式对于javascript。模式应该用在正确的地方。而哪些才算正确的地方，只有在我们深刻理解了模式的意图之后，再结合项目的实际场景才会知道。。 模式的社区一直在发展。GoF在1995年提出了23种设计模式，但模式不仅仅局限于这23种，后面增加到了24种。在这20多年的时间里，也许有更多的模式已经被人发现并总结了出来，比如一些JavaScript 图书中会提到模块模式、沙箱模式等。这些“模式”能否被世人公认并流传下来，还有待时间验证。 背景介绍摘自文章 发布订阅模式与观察者模式 有介绍这两种模式的区别 所有的设计模式都是一种思想：优化代码也业务逻辑的 [发布订阅设计模式 =&gt; 观察者模式的升级版] 情景再现：当某一个时间点或者某个条件到达的时候，我们需要处理很多事情，例如，我们从服务器获取数据（一般是异步获取），需要后续处理很多的事情 观察者模式（Observer Pattern） 观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。 观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系 发布订阅模式（Pub-Sub Pattern） 其实24种基本的设计模式中并没有发布订阅模式，上面也说了，他只是观察者模式的一个别称或者说是升级版。 但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。 在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为消息代理或调度中心或中间件，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。 举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）。 发布订阅模式的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 封装发布订阅库 */(function anonymous() { class Sub { // 创建一个事件池，并且挂载到实例上 pond = {}; // 向事件池中追加方法 on(flag, func) { // 首先校验新增的标识是否存在事件池中（不存在，我们创建一个这样的标识，并且初始值是一个空的数组，用来存储后续增加的方法；如果存在就拿到现有的数组） let pond = this.pond; if (!pond.hasOwnProperty(flag)) { pond[flag] = []; } let arr = pond[flag]; //每次增加之前做一个去重 if (!arr.includes(func)) { arr.push(func); } } // 从事件池中移除方法 off(flag, func) { let pond = this.pond; let arr = pond[flag]; // 如果移除的标识不在事件池中，说明之前从没有设置过这个标识的方法，也就不需要再移除了 if (!arr) return; for (let i = 0; i &lt; arr.length; i++) { // 增加的时候是去重的，所以移除的时候，只需要移除一个就够了 if (arr[i] === func) { // 为了防止数据塌陷，我们删除的时候，不去改变原生数组的索引，我们把当前项先赋值为null即可 // arr.splice(i, 1); arr[i] = null; break; } } } // 通知事件池中的方法执行 fire(flag, ...params) { let arr = this.pond[flag]; if (!arr) return; for (let i = 0; i &lt; arr.length; i++) { let item = arr[i]; // 把当前项不是函数的，从数组中移除掉即可 if (typeof item !== &quot;function&quot;) { arr.splice(i, 1); i--; continue; } item.call(this, ...params); } } } // 放到全局 window.subscribe = function subscribe() { return new Sub(); };})(); 测试效果123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script src=&quot;js/subscribe.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function fn1() { console.log(1); } function fn2() { console.log(2); // 第一次通知MARRY执行，执行到FN2的时候，我们从事件池中移除 FN1/FN2 sub.off('marry', fn1); sub.off('marry', fn2); } function fn3() { console.log(3); } function fn4() { console.log(4); } let sub = subscribe(); // =&gt; 得到实例 sub.on('marry', fn1); sub.on('marry', fn2); sub.on('marry', fn3); sub.on('marry', fn4); sub.on('divorce', fn2); sub.on('divorce', fn3); // =&gt; 订阅完成 let i = 0; let timer = setInterval(() =&gt; { i++; if (i &gt; 2) { // =&gt; clearInterval(timer); return; } // 发布执行 sub.fire('marry', 10, 20); // =&gt; 每隔两秒发布一次 'marry'事件池里的函数，这里一共执行了两次 // =&gt; 第一次控制台等待两秒后输出 1 2 3 4 ， 在fn2执行时移除了 'marry'事件池中的 fn1 和 fn2 // =&gt; 再两秒后第二轮发布控制台输出 3 4 }, 2000);&lt;/script&gt; ~~困了。睡觉","link":"/posts/fc4d7eca/"},{"title":"JavaScript - 模块的循环加载","text":"一、什么是循环加载? “循环加载”（circular dependency） 指的是：如a脚本执行中依赖(导入)了b脚本，而b脚本执行中又依赖了a脚本 12345// a.jsconst b = require('b');// b.jsconst a = require('a'); 一般情况下，循环加载 表示存在 强耦合 ，如果处理不好，可能会导致递归引用无限加载，导致程序无法正常继续运行。 二、CommonJS 加载规范1. CommonJS模块的加载原理CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。 123456{ id: '...', // 模块名 exports: { ... }, // 模块输出的各个接口(即导出的属性) loaded: true, // 布尔值，表示该模块的脚本是否执行完毕 ... // 更多属性...} 当 loaded 为true时，则表示此模块已加载完成，进入模块缓存区。以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。 CommonJS 输出值的拷贝 CommonJS 模块输出的是值的拷贝(原始值的拷贝)，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 12345678910111213141516// a.jsvar b = require('./b');console.log(b.foo);setTimeout(() =&gt; { console.log(b.foo); console.log(require('./b').foo);}, 1000);// b.jslet foo = 1;setTimeout(() =&gt; { foo = 2;}, 500);module.exports = { foo: foo,}; 执行 a.js 1234$ node a.js&gt; 1&gt; 1&gt; 1 上面代码说明，b 模块加载以后，它的内部 foo 变化就影响不到输出的 exports.foo 了。这是因为 foo 是一个原始类型的值，会被缓存。所以如果想要在 CommonJS 中动态获取模块中的值，那么就需要借助于函数延时执行的特性。 123456789101112131415161718// a.jsvar b = require('./b');console.log(b.foo());setTimeout(() =&gt; { console.log(b.foo()); console.log(require('./b').foo());}, 1000);// b.jslet foo = 1;setTimeout(() =&gt; { foo = 2;}, 500);module.exports = { foo: () =&gt; { return foo; },}; 执行 a.js 1234$ node a.js&gt; 1&gt; 2&gt; 2 总结一下： CommonJS 被重复引入的模块不会重复执行，会直接获取到该模块暴露出的 module.exports 对象 如果要实时获取模块中的最新值，则需要用其他的方式去更新 module.exports 上的值 如果 module.exports 暴露出的属性都是 引用类型 的值。那么就不存在这个问题了 2. CommonJS模块的循环加载CommonJS的重要特性是边执行代码，边加载(同步)require导入模块。即脚本代码在require的时候，就会全部执行。CommonJS的做法是，一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 详细可查看 官方文档 里面的例子。 下面将参照文档中的例子，试一试。 脚本文件a.js代码如下。 1234567exports.done = false;const B = require('./b.js');console.log('在a.js中输出 b.js 导出的 done值为：', B.done);exports.done = true;exports.done2 = 'done2'; 脚本文件b.js代码如下。 12345const A = require('./a.js');exports.done = true;console.log('在b.js中输出 a.js导出的 done值为：', A.done);console.log('在b.js中输出 a.js导出的 done2值为：', A.done2); 执行 a.js : 1234$ node a.js&gt; 在b.js中输出 a.js导出的 done值为： false&gt; 在b.js中输出 a.js导出的 done2值为： undefined&gt; 在a.js中输出 b.js 导出的 done值为： true 可以看到，在a脚本中执行到第二行立即就去加载执行了b脚本。在b脚本中又去读取了a脚本，但此时a脚本只执行到了第二行。所以b脚本中就只能导入a脚本已执行的部分。故此输出A模块的done值为false，而done2是undefined。 当b脚本执行完毕以后，a脚本才继续往下执行。 接着写一个脚本main.js，验证这个过程。 脚本文件main.js代码如下。 1234567const A = require('./a.js');const B = require('./b.js');console.log('A.done:', A.done); console.log('A.done2:', A.done2); console.log('B.done:', B.done); 执行 main.js 1234567$ node main.js&gt; 在b.js中输出 a.js导出的 done值为： false&gt; 在b.js中输出 a.js导出的 done2值为： undefined&gt; 在a.js中输出 b.js 导出的 done值为： true&gt; A.done: true&gt; A.done2: done2&gt; B.done: true 上面的代码证明了两件事: 在b.js之中，a.js没有执行完毕，只执行了部分。 main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果。即： 1exports.done = true; 三、ES6模块的循环加载1. babel-node提供一个自己在本地调试 js 代码时常使用的方式：使用 babel-node 命令，来运行含有 import/export 语法的 js 代码。 注意：babel-node 不能用于生产环境！因为 babel-node 会加载更多资源和模块，使得运行环境变「重」。 babel @7.x ~ 1$ npm i -g @babel/core @babel/node 项目根目录中下执行： 1$ npm i @babel/preset-env –save-dev .babelrc 文件配置 123{ &quot;presets&quot;: [&quot;@babel/preset-env&quot;]} 2. ES6模块的加载机制ES6 模块跟 CommonJS 模块的不同，主要有以下两个方面： ES6 模块输出的是值得引用，输出接口动态绑定。而 CommonJS 输出的则是值得拷贝 ES6 模块编译时执行，而 CommonJS 模块总是在运行时执行加载 ES6模块机制：在遇到模块加载命令import时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。 123456789101112131415// a.jsimport { foo } from './b';console.log(foo);setTimeout(() =&gt; { console.log(foo); import('./b').then(({ foo }) =&gt; { console.log(foo); });}, 1000);// b.jsexport let foo = 1;setTimeout(() =&gt; { foo = 2;}, 500); 执行命令：babel-node a.js 1234$ babel-node a.js&gt; 1&gt; 2&gt; 2 可以假想为 ES6模块机制把 “整个模块当作了一个引用闭包” ES6 静态编译 import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。 export 命令会有变量声明提前的效果。 关于 export 变量声明提升: 正常的引入模块是没办法看出变量声明提升的特性，需要通过循环依赖加载才能看出。 123456789101112131415// a.jsimport { foo } from './b';console.log('a.js');export const bar = 1;export const bar2 = () =&gt; { console.log('bar2');};export function bar3() { console.log('bar3');}// b.jsexport let foo = 1;import * as a from './a';console.log(a); 执行 123$ babel-node a.js&gt; { bar3: [Function: bar3], bar: undefined, bar2: undefined }&gt; a.js export 导出提升类似于 es5 机制中的变量提升机制。 由function声明的函数会在提升命名的同时一并赋值 (es5机制) 3. ES6 模块循环依赖跟 CommonJS 模块一样，ES6 不会再去执行重复加载的模块，又由于 ES6 动态输出绑定的特性，能保证 ES6 在任何时候都能获取其它模块当前的最新值。 12345678910111213141516// a.jsconsole.log('a starting')import {foo} from './b';console.log('in b, foo:', foo);export const bar = 2;console.log('a done');// b.jsconsole.log('b starting');import {bar} from './a';export const foo = 'foo';console.log('in a, bar:', bar);setTimeout(() =&gt; { console.log('in a, setTimeout bar:', bar);})console.log('b done'); 执行 a.js 1234567$ babel-node a.js&gt; in a, bar: undefined&gt; b done&gt; a starting&gt; in b, foo: foo&gt; a done&gt; in a, setTimeout bar: 2 ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，以及变量总是绑定其所在的模块。 这导致ES6处理”循环加载”与CommonJS有本质的不同。ES6根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。","link":"/posts/41c7d5fc/"},{"title":"JS-贪吃蛇小游戏","text":"设定规则需求 点击开始游戏 初始化一个蛇头+两个身体，默认向右移动 食物位置随机坐标，每次食物生成时的坐标不能和蛇身坐标重复 键盘四个方向键控制蛇头移动方向 撞到墙(地图边界)、撞到自己(蛇身)游戏失败 撞到食物，吃掉，蛇身加一。重新生成食物 ES5-构造函数模式 面向对象OOP：封装、继承、多态 使用JS的ES5版本进行开发。 JS —– 面向对象思想。这个游戏主要利用到了封装。。 js代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256// map-size : 100 * 100 = 12 * 9 || 50 * 50 = 24 * 18var map = document.getElementById('snakeWrap'), startBtn = document.getElementById('start');var snakeGame = (function () { var sw = 50, sh = 50, row = 1200 / sw, col = 900 / sh; // create Food function Food() { this.foodPos = this.randomPos(); this.foodView = new CreateDiv(this.foodPos.x, this.foodPos.y, 'food').create(); }; Food.prototype.randomPos = function () { var foodPos; var include = true; while (include) { foodPos = { x: Math.floor(Math.random() * row), y: Math.floor(Math.random() * col) } include = snake.includePos(foodPos); }; return foodPos; } // create div function CreateDiv(x, y, name) { this.x = x * sw; this.y = y * sh; this.class = name; this.viewEle = document.createElement('div'); this.viewEle.className = this.class; this.parent = document.getElementById('snakeWrap'); } CreateDiv.prototype.create = function () { this.viewEle.style.width = sw + 'px'; this.viewEle.style.height = sh + 'px'; this.viewEle.style.position = 'absolute'; this.viewEle.style.left = this.x + 'px'; this.viewEle.style.top = this.y + 'px'; this.parent.appendChild(this.viewEle); return this; } CreateDiv.prototype.remove = function () { this.parent.removeChild(this.viewEle); } // snake function Snake() { this.head = null; this.tail = null; // x,y all position this.pos = [ [2, 0], [1, 0], [0, 0] ]; // direction change this.directionStorage = { right: { x: 1, y: 0 }, left: { x: -1, y: 0 }, up: { x: 0, y: -1 }, down: { x: 0, y: 1 } }; // storage view this.snakeViewEle = []; } // test next position Snake.prototype.PosTesting = function () { if (!game.timer) return; var nextPos = { x: this.head[0] + this.direction.x, y: this.head[1] + this.direction.y }; // console.log(nextPos); // test food if (nextPos.x === this.curFood.foodPos.x &amp;&amp; nextPos.y === this.curFood.foodPos.y) { this.eat(); return true; } // test self if (this.includePos(nextPos)) { game.gameOver(); return; } // test boundary if (nextPos.x &gt;= row || nextPos.y &gt;= col || nextPos.x &lt; 0 || nextPos.y &lt; 0) { game.gameOver(); return; } // GO this.pos.unshift([nextPos.x, nextPos.y]); this.play(); return true; } // Snake start Snake.prototype.play = function (eat) { // for (var i = 0; i &lt; this.snakeViewEle.length; i++) { var curView = this.snakeViewEle[i]; var curPos = this.pos[i]; curView.viewEle.style.left = curPos[0] * sw + 'px'; curView.viewEle.style.top = curPos[1] * sh + 'px'; } this.head = this.pos[0]; if (eat) { this.curFood = new Food; game.score++; return; } this.pos.pop(); } // eat food Snake.prototype.eat = function () { this.pos.unshift([this.curFood.foodPos.x, this.curFood.foodPos.y]); this.curFood.foodView.viewEle.className = 'snakeBody'; this.snakeViewEle.push(this.curFood.foodView); this.play(true); } Snake.prototype.includePos = function (objPos) { for (var i = 0; i &lt; this.pos.length; i++) { var item = this.pos[i]; if (item[0] === objPos.x &amp;&amp; item[1] === objPos.y) { return true; } else if (i == this.pos.length - 1) { return false; } } } Snake.prototype.init = function () { // init snake var head = new CreateDiv(this.pos[0][0], this.pos[0][1], 'snakeHead').create(), body1 = new CreateDiv(this.pos[1][0], this.pos[0][1], 'snakeBody').create(), body2 = new CreateDiv(this.pos[2][0], this.pos[0][1], 'snakeBody').create(); // init food &amp;&amp; storage position this.curFood = new Food; // init direction this.direction = this.directionStorage.right; // pos relation this.head = this.pos[0]; this.snakeViewEle.push(head, body1, body2); } // control direction function control(e) { if (e.keyCode === 37 &amp;&amp; snake.direction !== snake.directionStorage.right) { snake.direction = snake.directionStorage.left; game.snakeTurnHead(); } else if (e.keyCode === 38 &amp;&amp; snake.direction !== snake.directionStorage.down) { snake.direction = snake.directionStorage.up; game.snakeTurnHead(); } else if (e.keyCode === 39 &amp;&amp; snake.direction !== snake.directionStorage.left) { snake.direction = snake.directionStorage.right; game.snakeTurnHead(); } else if (e.keyCode === 40 &amp;&amp; snake.direction !== snake.directionStorage.up) { snake.direction = snake.directionStorage.down; game.snakeTurnHead(); } } // define game function Game() { this.timer = null; this.score = 0; } // reset map Game.prototype.gameOver = function () { clearInterval(this.timer); alert(&quot;得分 : &quot; + this.score); // remove onkeydown document.body.removeEventListener('keydown', control, false); startBtn.parentNode.style.display = &quot;block&quot;; snake.snakeViewEle = []; map.innerHTML = ''; snake.pos = [ [2, 0], [1, 0], [0, 0] ]; this.score = 0; } // turn direction Game.prototype.snakeTurnHead = function () { this.stop(); snake.PosTesting() &amp;&amp; this.start(); } // stop Game.prototype.stop = function () { clearInterval(this.timer); this.timer = true; } // start Game.prototype.start = function () { this.timer = setInterval(function () { // PosTest &amp;&amp; play snake.PosTesting(); }, 250); } // init game Game.prototype.init = function () { clearInterval(this.timer); snake.init(); this.start(); // monitor onkeydown document.body.addEventListener('keydown', control, false); } // create example var snake = new Snake; var game = new Game; // return example return { snake, game } // End})();// start gamestartBtn.onclick = function () { this.parentNode.style.display = 'none'; snakeGame.game.init();}; css代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657*{margin: 0; padding: 0;}body{background-color: #f3f3f3;}.content{ width: 1200px; height: 900px; margin: 10px 0 0 10px; position: relative;}/* btn */.content .btn{ width: 100%; height: 100%; background-color: rgba(255, 255, 255, .3); position: absolute; left: 0; top: 0; display: none;}.content .btn:last-child{ display: block;}.content .btn button{ width: 120px; height: 80px; font-size: 42px; display: block; margin: 35% auto;}/* 12 * 9 *//* snakeWrap */#snakeWrap{ width: 1200px; height: 900px; background-color: #000; position: absolute; top: 0; left: 0;}#snakeWrap div{ width: 100px; height: 100px; background-repeat: no-repeat; background-size: cover;}/* snake style */#snakeWrap .snakeHead{ background-color: #ff0000;}#snakeWrap .snakeBody{ background-color: #e0de43;}#snakeWrap .food{ background-color: #fff;} html代码12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;snake&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./snake.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;content&quot;&gt; &lt;div id=&quot;snakeWrap&quot;&gt;&lt;/div&gt; &lt;div class=&quot;btn&quot;&gt;&lt;button id=&quot;start&quot;&gt;开始&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./snake.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 小结：游戏效果图： 大概实现的差不多了。 但还有一些地方可以优化一下，例如蛇的移动方式，上面采用的是循环坐标，让蛇身挨个前进。这样的方式不免有些 ‘笨重’。随蛇身越来越长，代码性能不高。 可以采用的优化方式：利用 ‘掐头去尾’ 实现移动动作。即在撞到食物时，删除食物，且新建一个蛇头，坐标为食物的坐标。 随之删除蛇身尾部，新建一个蛇身 ，覆盖旧蛇头的位置。 这样每次撞到食物只需操作蛇头和蛇尾就可以了。 先不优化了，睡了睡了~","link":"/posts/ba633e46/"},{"title":"CodeMirror - 使用","text":"CodeMirror简单介绍CodeMirror 是一个用 JavaScript 为浏览器实现的多功能文本编辑器。它专门用于编辑代码，并带有 100 多种语言模式和各种实现更高级编辑功能的插件。每种语言都带有功能齐全的代码和语法突出显示，以帮助阅读和编辑复杂的代码。 支持切换主题、语法高亮、代码折叠。 多种已有的语言模式开箱即用。（可自己编写新的语言模式） …… 简单使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;CodeMirror&lt;/title&gt; &lt;!-- 核心样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../../node_modules/codemirror/lib/codemirror.css&quot; /&gt; &lt;!-- 主题样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../../node_modules//codemirror/theme/ambiance.css&quot; /&gt; &lt;!-- 核心脚本 --&gt; &lt;script src=&quot;../../../node_modules/codemirror/lib/codemirror.js&quot;&gt;&lt;/script&gt; &lt;!-- 语言模式脚本 --&gt; &lt;script src=&quot;../../../node_modules/codemirror/mode/javascript/javascript.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;../../../node_modules/codemirror/mode/clike/clike.js&quot;&gt;&lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;layout&quot;&gt; &lt;!-- &lt;textarea name=&quot;&quot; id=&quot;myTextArea&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;function myScript(){return 100;}&lt;/textarea&gt; --&gt; &lt;/div&gt; &lt;script&gt; var container = document.body; var editorConfig = { // 编辑器的起始值 value: 'function myScript(){return 100;}\\n', // 编辑语言 mode: 'javascript', // mode: 'text/x-java', // x-: csrc c++src java // 主题 theme: 'ambiance', // tab缩进宽度 tabSize: 2, // 显示行数 lineNumbers: true, }; var myCodeMirror = CodeMirror(container, editorConfig); console.log(myCodeMirror.getValue(), '获取value'); setTimeout(() =&gt; { // 设置value myCodeMirror.setValue('var message = &quot;hello world&quot;'); }, 1000); /** * @param instance: CodeMirror实例 * @param changeObj: 是一个{from, to, text, removed, origin}有关所发生作为第二个参数的变化包含对象的信息。 * from 和 to 是更改开始和结束的位置（在更改前的坐标系中）例如，{ch:0, line:18}。 * text 是一个字符串数组，表示替换更改范围的文本（按行拆分）。 * removed 是被更改之前的内容，它被此更改覆盖。 * 此事件在操作结束之前、DOM 更新发生之前触发。 */ myCodeMirror.on('change', function (instance, changeObj) { console.log(changeObj, 'changeObj'); }); &lt;/script&gt; &lt;!-- &lt;script&gt; // 接受一个 textarea DOM 节点作为第一个参数，一个可选的配置对象作为第二个参数。 // 它将用 CodeMirror 实例替换 textarea，并连接该 textarea 的表单（如果有）以确保在提交表单时将编辑器内容放入 textarea。 // textarea 中的文本将为编辑器提供内容。 var myTextArea = document.getElementById('myTextArea'); var editorConfig = { // 编辑语言 mode: 'javascript', // 主题 theme: 'ambiance', // tab缩进宽度 tabSize: 2, // 显示行数 lineNumbers: true, }; var myCodeMirror = CodeMirror.fromTextArea(myTextArea, editorConfig); &lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; React-CodeMirror2Github: https://github.com/scniro/react-codemirror2 Npm: https://www.npmjs.com/package/react-codemirror2 基于codemirror二次封装，集成为react中的一个插件，在react中使用 安装 1npm install react-codemirror2 codemirror --save 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/* * CodeMirror React版 -- https://github.com/scniro/react-codemirror2 https://www.npmjs.com/package/react-codemirror2 * 受控 Controlled * 不受控 UnControlled * */import React, { useCallback, useEffect, useRef, useMemo, memo } from 'react';import PropTypes from 'prop-types';import { Controlled as CodeMirror } from 'react-codemirror2';import 'codemirror/lib/codemirror.css'; // 编辑器核心样式import 'codemirror/lib/codemirror.js'; // 编辑器核心js// 代码折行import 'codemirror/addon/fold/foldgutter.css';import 'codemirror/addon/fold/foldcode.js';import 'codemirror/addon/fold/foldgutter.js';import 'codemirror/addon/fold/brace-fold.js';import 'codemirror/addon/fold/comment-fold.js';// 全屏开启import 'codemirror/addon/display/fullscreen.css';import 'codemirror/addon/display/fullscreen.js';// 光标所处行高亮import 'codemirror/addon/selection/active-line';// 语言模式import 'codemirror/mode/sql/sql.js';import 'codemirror/mode/clike/clike.js'; // 类C （c \\ c++ \\ java \\ ...）import './index.scss';// 暂支持三种语言const supportLanguage = ['sql', 'mysql', 'java'];/** * @description: * @param {string} 目前暂支持 sql java */const CodeEditor = ({ className, onChange, value, width, height, placeholder, language, fullScreen, onExitFullScreen,}) =&gt; { const editorContainerRef = useRef(null); /** * @description: 退出全屏 * @default Esc keyCode === 27 * @param {KeyboardEvent} e */ const exitFullScreen = useCallback( ({ keyCode }) =&gt; { if (keyCode === 27) onExitFullScreen(); }, [onExitFullScreen] ); useEffect(() =&gt; { const containerElement = editorContainerRef.current; if (fullScreen &amp;&amp; containerElement) { containerElement.addEventListener('keydown', exitFullScreen, false); return; } containerElement.removeEventListener('keydown', exitFullScreen); }, [fullScreen]); /** * @description: 编辑器初始挂载完毕 */ const editorDidMount = useCallback(editor =&gt; { editor.on('inputRead', cm =&gt; { cm.execCommand('autocomplete'); }); }, []); /** * @description: 编辑器输入change事件 * @param {any} editor 编辑器所有信息（CodeMirror实例） * @param {any} data 当前数据信息 * @param {string} value 当前值 */ const onInnerChange = useCallback((editor, data, value) =&gt; { onChange(value); }, []); const mode = useMemo(() =&gt; { if (supportLanguage.includes(language.toLowerCase())) { return { name: `text/x-${language}`, }; } return { name: '', }; }, [language]); const editorConfig = useMemo( () =&gt; ({ // 语言模式 mode, // 主题 theme: 'blackboard', // 显示行号 lineNumbers: true, // 自动获取焦点 autofocus: true, // 光标所处行代码高亮 styleActiveLine: true, // 自动换行 lineWrapping: true, // 代码折行 foldGutter: true, gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'], // 代码提示补全（按ctrl+空格键即可调出，可自定义配置快捷键 extraKeys: { Ctrl: 'autocomplete' }, hintOptions: { completeSingle: false }, // 全屏 fullScreen, }), [mode, fullScreen] ); return ( &lt;div style={{ width, height }} ref={editorContainerRef} className={`code-editor-container ${className || ''}`} &gt; &lt;CodeMirror options={editorConfig} value={value ?? placeholder} onBeforeChange={onInnerChange} // 这个事件最好加上，可以是空函数。否则在一些情况下，第二次打开就会有未知的问题（报错） editorDidMount={editorDidMount} /&gt; &lt;/div&gt; );};CodeEditor.propTypes = { className: PropTypes.string, language: PropTypes.string, fullScreen: PropTypes.bool, onChange: PropTypes.func.isRequired, onExitFullScreen: PropTypes.func.isRequired,};CodeEditor.defaultProps = { onChange: () =&gt; {}, onExitFullScreen: () =&gt; {}, language: 'java', fullScreen: false, className: '',};export default memo(CodeEditor); ……","link":"/posts/3f01d2c5/"},{"title":"开箱：索蔡定焦 55mm F1.8","text":"心心念念的定焦头终于到货了~ 这是入坑摄影以来的第二颗镜头。 简单介绍一下这颗镜头 焦距：定焦头，全画幅下55毫米。 APS-C画幅下的35mm规格换算焦距为：82.5毫米 光圈：最大F1.8 ， 最小F22 重量：281克 (nice 😄，跟我的A7C很搭) 尺寸：64.4 x 70.5（体积很nice！适马大炮警告⚠️哈哈 ） 滤光镜直径：49毫米 （赞） 最近对焦距离约：50厘米 （就是距离半米之内对不上焦。差评😈） …. （other） Sonnar T* FE 55mm F1.8 ZA 定焦镜头。上市时间是2013年10月份，距离现在已经过去9年了。（WTH ? 四九入国军了！！）虽说数码、电子类产品一向秉承买新不买旧，但这颗镜头从上市以来至今饱受好评，有太多人使用它拍出来很多非常棒的作品。更有人称之为’入门必备镜头’。算是一个经典头了。 个人认为的一些优点：色彩不错，照片与视频表现都很好原厂镜头，蔡司镀膜。对焦速度快体验好。（毕竟亲儿子）外观好看。体积小，重量轻，直筒规整形状较为符合个人审美。蔡司小蓝标信仰加成！（颜值即正义😋）搭配我的A7C小机身比较合适。轻便会更有带出去的意愿。….. 当然也有一些缺点: 最近对焦距离50厘米有点无奈… 有个外号，江湖人称 ‘紫霞仙子’ 。自己实测某些光线场景下确实会有较为明显的紫边。（不过对于我这种非专业人士来说，那都不是事~） 有点小贵emmm （九年老头了！价格真坚挺） 镜头实物照片 我的手机拍摄素质太渣了….镜头其实很好看。 外出实拍照片 出去扫街咯~！！ 。。。。。。呃 嗯emmm…… 好像拍的挺一般的呃。 还没有一些主打拍摄的手机成片好看呢Oh。 开启狡辩模式：一定是直出的原因！没后期！场景不行！没有三脚架的原因！今天天气不好！冻手太抖了！路人不配合😓！ ………… （🐶不承认自己拍摄技术菜🐶） 最后晚上顶着很冷的气温，顶着社恐心理去扫街拍了几十张，回到家发现竟没一张自己满意的照片。但我也没有很失落吧，因为我的拍摄经历一直都是这样😂 哈哈哈 自从有了相机后才发现摄影并不是自己想象的那么简单，有很多的参数知识，构图审美，后期调色等知识需要去学习。不是按一下快门就能出好看的照片，也讲究天时地利人和。尤其是扫街这种人文摄影，随机性很多。一些美好的画面往往只有一瞬间，没能及时抓拍到就很难再有机会了（像极了人生机遇。 ?怎么突然正经🙅🏻‍♀️？） 一直觉得 “愈挫愈勇” 这句成语更能体现出什么是纯粹的 热爱摄影是一种利用光的艺术，保持热爱","link":"/posts/77b658d2/"},{"title":"VUE-component","text":"VUE中的组件组件的特点是： 每个组件就是一个自定义标签 可复用 方便维护 方便拆分 每个组件作用域隔离（互不干扰） 有完整的生命周期 有自己的响应式数据和各种方法（事件） … 组件的组织 通常一个应用会以一棵嵌套的组件树的形式来组织： 1. 全局组件 &amp; 组件的基本语法 在任何组件中可以直接使用（不需要引入，直接在组件模板中调用即可）Vue.component(componentName,options) 组件名字中的一点规范 kebab-case：只能&lt;kebab-case&gt;调用 PasalCase：既可类似前种方式调用，也可以&lt;pasalcase&gt;方式调用（渲染的时候会把所有单词字母都渲染为小写，但是在组件中可以大写） 调用组件的细节规范 采用双闭合方式 单闭合方式不符合w3c规范（只能识别一个） template 每个组件只能有一个根元素 模板字符串方式 template标记方式 slot插槽处理 基础操作 多插槽的指定 data必须是一个函数，保证不同组件之间的数据互不干扰（返回的对象中初始化数据） … 2. 局部组件 创建组件：let componenName={…} 基于components属性声明组件：想用哪个组件需要先声明 使用组件 3. 组件信息通讯之父传子：props属性传递 父组件调用到的时候 1&lt;my-component aa='AAAA' :bb='xxx'&gt;&lt;/my-component&gt; 子组件中基于props声明需要接收的属性值 1234Vue.component('my-component',{ props:['aa','bb'], ...}) props中声明的属性和data一样，是响应式数据，挂载到vm实例上，可控制视图渲染 props中的一些细节问题 命名大小写：传递的是kebab-case格式，props中获取的是camelCase驼峰命名 指定属性的类型：props:{xxx:String,…} 指定属性的默认值：props:{xxx:{type:String,default:’xxx’,required:true}} type如果是一个数组，意为指定的多类型皆可以 default可以是一个函数，函数返回值是默认值 validator自定义验证规则函数：必须符合函数中指定的规则，返回true/false 传递的属性值默认都是字符串格式，如果想要让传递的值是数字、布尔、数组、对象等格式，我们需要使用v-bind处理 样式和class自动合并问题 4. Vue的单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。 Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分： 加载渲染过程：父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子beforeMount-&gt; 子 mounted -&gt; 父 mounted 子组件更新过程：父 beforeUpdate -&gt; 子beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程：父 beforeUpdate -&gt; 父 updated 销毁过程：父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着不应该在一个子组件内部改变 prop。如果这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。有两种常见的试图改变一个 prop 的情形 : 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 5. 组件信息通讯之子改父：this.$emit 订阅自定义事件：调用组件的时候基于属性传递一个方法 （父）123456789&lt;my-component @func='xxx'&gt;&lt;/my-component&gt;new Vue({ methods:{ xxx(value){ //=&gt; value是this.$emit时候传递的第二个参数值 } }}); 通知自定义事件执行 （子）1234567{ methods:{ xxx(){ this.$emit('func',10); } }} 也可以基于此方法实现兄弟组件（父子组件、隔代组件）之间的信息通信1234567let eventBus=new Vue; //=&gt;创建事件总线//A组件eventBus.$on('xxxA',this.func);//B组件eventBus.$emit('xxxA'); 6. 基于ref实现父子组件信息通信 ref 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，基于此可以快速获取和操作子组件中的数据 $parent和$children是获取父组件和子组件的实例，只不过$children是一个数组集合，需要记住组件顺序才可以 7. 基于provide和inject实现祖先与后代的通信 祖先组件基于provide注册需要供后代组件使用的数据1234567{ provide:{ //=&gt;对象或者返回对象的函数都可以（属性值如果是data中的数据，则必须使用函数的方法进行处理） name:'zhangsan', year:10 }, ...} 后代组件基于inject声明需要使用的数据并调取使用12345678{ inject:['name'], methods:{ func(){ let name=this.name; } }} 更多Vue官方文档 ==&gt; 深入了解组件","link":"/posts/b0880b06/"},{"title":"Vue数据双向绑定原理","text":"MVC &amp; MVVM 传统操作DOM模式 MVC：model view controller MVVM：model view viewModel 双向数据绑定的实现原理 Object.defineProperty 实现的底层原理 : 123456789101112131415161718192021222324252627//obServer:观察者function obServer(obj) { if (obj &amp;&amp; typeof obj === 'object') { for (let key in obj) { if (!obj.hasOwnProperty(key)) break; defineReactive(obj, key, obj[key]); } }}function defineReactive(obj, key, value) { obServer(value); Object.defineProperty(obj, key, { get() { return value; }, set(newValue) { observer(newValue); if (value === newValue) return; value = newValue; } });}function $set(data, key, value) { defineReactive(data, key, value);} 核心原理及代码实现 解析Vue指令的 —— v-model 编译Vue中的取值语法 —— { {...} } 实现对表单元素input 双向数据监听 这次使用ES6定义class类的形式来实现。就不使用ES5了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue-MVVM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p a=&quot;21&quot;&gt;{{ msg }} &amp;nbsp; 这是静态文本&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;val&quot;&gt; &lt;div&gt; &lt;p&gt;{{ val }} 静态文本&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://fastly.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* * obServer: 数据监听（拦截） * compile: 指令解析 * Dep: 订阅器（事件池，发布器） * Watcher: 订阅者：（订阅） */ // Dep class Dep { constructor() { this.subs = []; } subscribe(sub) { this.subs.push(sub); } notify(oldValue) { console.log(this.subs); this.subs.forEach(item =&gt; { item.update(oldValue); }); } } // Watcher class Watcher { constructor(node, key, vm) { this.node = node; this.key = key; this.vm = vm; Dep.curWatcher = this; this.getData(); Dep.curWatcher = null; } getData() { return this.vm._data[this.key]; } update(oldValue) { if (this.node.nodeType == 1) { if (this.node.nodeName === &quot;INPUT&quot;) { this.node.value = this.getData(); } // ..... } else { let oldText = this.node.nodeValue; this.node.nodeValue = oldText.replace(oldValue, this.getData()); } } } class myVue { constructor(options) { let _this; //=&gt; init example this._data = typeof options.data === &quot;function&quot; ? options.data() : options.data; this.$el = document.querySelector(options.el); // data obServer this.obServer(this._data); // nodeToFragment &amp;&amp; Compile this.nodeToFragment(this.$el); this.$root = this; _this = Object.assign(this._data, this); return _this; } // prototype obServer(data) { if (data &amp;&amp; typeof data === &quot;object&quot;) { for (let key in data) { if (!data.hasOwnProperty(key)) break; this.defineReactive(data, key, data[key]); } } } // data intercept defineReactive(data, key, value) { this.obServer(value); const dep = new Dep(); let oldValue = value; Object.defineProperty(data, key, { get() { if (Dep.curWatcher) { dep.subscribe(Dep.curWatcher); } return value; }, set(newValue) { if (newValue === oldValue) return; oldValue = value; value = newValue; dep.notify(oldValue); } }); } // instruct-model instructModel(node, attr) { // 可根据input不同的type类型，设置不同的属性。 如： checked let nodeValue = attr.nodeValue, nodeName = attr.nodeName; node.value = this._data[nodeValue]; // nodeValue 取到 data 中对应的字段 node.removeAttribute(nodeName); // 删除行间指令 node.addEventListener(&quot;input&quot;, ev =&gt; { this._data[nodeValue] = ev.currentTarget.value; }, false); // 创建观察者（监听） new Watcher(node, nodeValue, this); } // Compile compile(node) { if (node.nodeType == 1) { // 获取元素的节点的行间属性 let attrs = node.attributes, nodes = node.childNodes; for (let i = 0; i &lt; attrs.length; i++) { let curAttr = attrs[i], curAttrName = curAttr.nodeName; if (/^v\\-/.test(curAttrName)) { switch (curAttrName.substring(2)) { //=&gt; 匹配对应v-指令 case &quot;model&quot;: this.instructModel(node, curAttr); break; // .... 更多指令 }; } } // 递归处理其子节点 for (let i = 0; i &lt; nodes.length; i++) { this.compile(nodes[i]); } } else { // 解析非元素节点 let text = node.nodeValue, reg = /\\{\\{(.+?)\\}\\}/g; if (reg.test(text)) { text = text.replace(reg, (g, key) =&gt; { key = key.trim(); if (key) new Watcher(node, key, this); return this._data[key]; }); node.nodeValue = text; } } } // nodeToFragment nodeToFragment(element) { let frag = document.createDocumentFragment(); let firstNode = element.firstChild; while (firstNode) { frag.appendChild(firstNode); this.compile(firstNode); firstNode = element.firstChild; } element.appendChild(frag); } }; const myVm = new myVue({ el: &quot;#app&quot;, data() { return { msg: &quot;这是一个动态添加的文本&quot;, val: 666 } } }); console.log(myVm); // const vm = new Vue({ // el: &quot;#app&quot;, // data() { // return { // msg: &quot;这是一个动态添加的文本&quot;, // val: 666 // } // } // }); // console.log(vm); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 看一下真Vue的效果： 再来看一下myVue:稍有瑕疵，问题不大 简单总结Vue 主要通过以下 4 个步骤来实现数据双向绑定的： 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。","link":"/posts/cec8bac/"},{"title":"Waline评论系统终终终终终于能用了~","text":"折腾了这么久的博客评论系统，可算是能告一段落了。😈 为什么最终选择了Waline？之前一直使用的是Gitalk，后来也不知道自己是哪根筋搭错了，觉得不好用又开始折腾了起来。然后先试了试Valine，正当觉得还不错时，就注意到有其它用户发现一个存在于Valine评论插件的漏洞会导致此评论服务暴露所有评论者的 IP地址 (xCss/Valine#336)。 请在此漏洞修复之前换用其他评论服务。so what ？直接换 Waline ！ 看一下Waline官网的一些介绍： 一款从 valine 衍生的带后端评论系统。可以将 Waline 等价成 With backend Valine. 特性：快速、真·安全、Markdown 语法支持、轻量易用、免费部署、多种部署部署方式和存储服务支持，每列选择一项多达 84 种部署方式任君选择… （emmm😂） 反正看着官方吹了一通牛皮，最让我感兴趣的还是那个独立服务端部署。废话不多说，直接开搞整起来！ Waline 配置先是看着官网的 快速上手 文档完整操作流程走了一遍。LeanCloud注册、创建应用、 Vercel 部署项目创建+环境变量设置、….等等一顿操作猛如虎。最后终于走完了流程，兴奋的去点击部署项目的 Visit 按钮去预览 – 自己测试了两条评论之后：哎呦~不错呦。然后赶紧按照接入流程去配置自己的博客项目，正当我自满时又注意到了第一条测试评论的位置信息 – 东京都😓好家伙，我还翻着墙呢。 因为我创建的是国际版，免费部署服务器和域名都是国外的（毕竟国内大环境，懂都都懂）。接着我便从墙上下来试了一通，虽然页面还是能正常打开，但是提交评论功能还是挂了。（靓仔此时非常不悦😯） 去网搜了一下答案，大概意思就是vercel.app域名在国内遭到污染无法访问。随后找到了两种解决办法： 如果你有申请过自己独立的博客域名，可以在博客顶级域名上添加一个二级子域名作为评论系统的使用域名。然后别忘了添加一条DNS解析记录：CNAME 类型解析指向 cname.vercel-dns.com 这个地址。 之后再去vercel部署服务上，点击settings，找到Domians将vercel上的waline地址指向你设置的子域名上。这样就完成了，后面配置博客的时候serverURL属性配置刚刚的子域名就好了。 使用其它的部署服务器代替vercel部署。也是我现在采用的方式。虽然我已有独立域名+备案，但就是想尝尝鲜😋 使用Deta服务端部署DETA官网 ：https://www.deta.sh/ 进入官网后还是老套路先注册，然后页面会自动引导你去创建一个默认的部署项目project 直接点这个链接进入： https://web.deta.sh/deploy?path=https://github.com/walinejs/deta-starter 将Waline快速部署到deta平台 deta平台部署完成以后也会自动生成一个随机域名链接。将这个链接配置到博客项目中serverURL属性就可以正常评论了。 参考文档：https://waline.js.org/guide/deploy/deta.html ！~~ end","link":"/posts/c0155143/"},{"title":"react-redux原理实现","text":"先简单了解一下 react-redux 一、组件分类React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。 UI 组件： 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 容器组件： 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态，可以将状态通过props给子组件 使用 Redux 的 API React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，我们只写UI组件，而顶层容器是通过调用一个方法来生成的 二、connect()方法React-Redux 提供了connect方法，用于将 UI 组件包装成容器组件。容器是要有状态有业务逻辑的，因此在connect方法生成顶层容器时，我们就应该把所需要的状态和业务逻辑定义好并提供给connect。因此，connect方法的完整 API 如下 123456import { connect } from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(component) 其中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。 三、&lt;Provider&gt; 组件connect方法生成容器组件时，我们定义了一堆的逻辑和状态，而只有顶层容器能拿到store的时候才有意义，因此需要让容器组件拿到store的state对象。 React-Redux 提供Provider组件，可以让组件树中的任意一个容器组件拿到state。 12345678910import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import { Provider } from &quot;react-redux&quot;;import store from &quot;./store/store.js&quot;;import App from &quot;./App&quot;;ReactDOM.render(&lt;Provider store={store}&gt; &lt;App&gt;&lt;/App&gt;&lt;/Provider&gt;, document.querySelector(&quot;#root&quot;)); 四、源码实现react-redux更多用法不多介绍, 详情参阅官方文档 &gt; React Redux文档 上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import React from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;// redux : bindActionCreators// import { bindActionCreators } from &quot;redux&quot;; // react-redux: 根组件 Provider; class Provider extends React.Component { constructor() { super(); } // 利用context上下文实现跨组件传递 static childContextTypes = { store: PropTypes.object } getChildContext() { return { store: this.props.store } } render() { console.log(this); // 返回Provider组件标签之内的子组件进行渲染 return &lt;&gt; {this.props.children} &lt;/&gt; }}// connect : 高阶函数，生成组件const connect = (mapStateToProps, mapDispatchToProps) =&gt; (Component) =&gt; { return class Connect extends React.Component { constructor(props, context) { super(); // 将store中的总state传入mapStateToProps,其返回部分的state数据或者自定义、全部的state this.state = mapStateToProps(context.store.getState()); } // 接收context属性 static contextTypes = { store: PropTypes.object } // 订阅函数，每当执行dispatch就更新视图 componentDidMount() { this.unSubscribe = this.context.store.subscribe( () =&gt; this.setState(mapStateToProps(this.context.store.getState())) ); } // 取消订阅 componentWillUnmount() { this.unSubscribe(); } render() { console.log(this); // mapDispatchToProps : 除传入函数以外，在react-redux中:connect第二个参数还可以直接传入actions对象。 // 如果是函数，将store.dispatch传入，执行接收其返回值。 // 如果是对象，就会调用redux中的api--&gt; bindActionCreators(); 将对象传入，进行dispatch二次包装成函数 let actions; if (typeof mapDispatchToProps === &quot;function&quot;) { actions = mapDispatchToProps(this.context.store.dispatch); } else if (typeof mapDispatchToProps === &quot;object&quot; &amp;&amp; mapDispatchToProps !== null) { // actions = bindActionCreators(mapDispatchToProps, this.context.store.dispatch); // redux内置 // 既然写到这里了，就不用redux内置的bindActionCreators方法了。还是自己封装一个吧 actions = bindActionCreators(mapDispatchToProps, this.context.store.dispatch); } else { actions = {}; } // 将指定的数据传入子组件，组件内部可以通过this.props获取 return &lt;&gt; &lt;Component {...this.state} {...actions}&gt;&lt;/Component&gt; &lt;/&gt; } }}// 封装丐版 bindActionCreators const bindActionCreators = (actionCreators, dispatch) =&gt; { const boundActionCreators = {}; for (let key in actionCreators) { const actionCreator = actionCreators[key]; if (typeof actionCreator === &quot;function&quot;) { boundActionCreators[key] = function (...arg) { dispatch(actionCreator.apply(this, arg)); } } } return boundActionCreators;}export { Provider, connect} 五、效果测试 小案列目录结构 index.js : 12345678910111213import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;// import { Provider } from &quot;react-redux&quot;;import { Provider } from &quot;./my-react-redux&quot;;import store from &quot;./store/store.js&quot;;import App from &quot;./App&quot;;ReactDOM.render(&lt;Provider store={store}&gt; &lt;App&gt;&lt;/App&gt;&lt;/Provider&gt;, document.querySelector(&quot;#root&quot;)); app.js : 1234567891011121314151617import React from &quot;react&quot;;import Parent from &quot;./components/Parent&quot;;import Child from &quot;./components/Child&quot;;export default class App extends React.Component { constructor(){ super(); } render(){ return &lt;div&gt; &lt;Parent&gt;&lt;/Parent&gt; &lt;Child&gt;&lt;/Child&gt; &lt;/div&gt; }} Parent.jsx : 123456789101112131415161718192021222324252627import React from &quot;react&quot;;import actions from &quot;../store/actions&quot;;import { connect } from &quot;../my-react-redux&quot;;class Parent extends React.Component { constructor() { super(); } changeNum = () =&gt; { this.props.changeNum(); } render() { console.log(this); return &lt;div&gt; {this.props.num} &lt;button onClick={this.changeNum}&gt;更改num&lt;/button&gt; &lt;/div&gt; }}// export default Parent;export default connect(state =&gt; ({ ...state }), actions)(Parent); 其他文件就不发了，直接看效果 点击更改num ，让num+1 。 更改age，让age+2 嗝嗝~~ 睡觉","link":"/posts/2f1230a5/"},{"title":"redux-compose.js","text":"redux是js模块开发中的一个状态管理库，与其他框架没有直接的关系，如：react。 所以redux可以直接在别的环境下使用。由于没有和react 相关逻辑耦合，所以 redux 的源码很纯粹，目的就是把如何数据管理好。而真正在 react 项目中使用 redux 时，是需要有一个react-redux当作连接器，去连接react和 redux 。 compose.jsredux基本的五个API中，compose.js是唯一一个能单独拿出来使用的函数。函数式编程中常用的组合函数，和redux本身联系不大 先看一下 compose.js 源码 1234567891011export default function compose(...funcs) { if (funcs.length === 0) { return arg =&gt; arg } if (funcs.length === 1) { return funcs[0] } return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))} 其实 compose 函数做的事就是把 A(B(C(10))); 这种嵌套的调用方式改成 compose(A, B, C)(10); 的方式调用。 123456789101112131415function A(x) { return x + 10;}function B(y) { return y - 10;}function C(z) { return z;}// 把一个函数执行的结果当作另外一个函数执行的实参// A(B(C(10))); // --&gt; 10 ⬇// compose(A, B, C)(10); 先简单了解下数组方法 reduce 12345678arr.reduce(function(prev,cur,index,arr){ // 参数介绍 arr 表示原数组； prev 表示上一次调用回调时的返回值，或者初始值 init; cur 表示当前正在处理的数组元素； index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1； init 表示初始值}, init); 利用reduce做一个number求和 123456[10, 20, 30, 40, 50].reduce((a, b) =&gt; { console.log(a, b); return a + b; // a : 每一次循环处理返回的结果；如果设置了init初始值，第一轮a就是init // b : 依次循环中数组的每一项}); 拆分reduce执行步骤，简单梳理一下处理流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function compose(...funcs) { if (funcs.length === 0) return; if (funcs.length === 1) return funcs[0]; // 箭头函数转成function形式 return funcs.reduce(function (a, b) { return function (...args) { return a(b(...args)); } }); // [A, B, C, D, E, F] ： 假设有六个函数 // 第一轮 a = A, b = B return function (...args) { return A(b(...args)) } // 第二轮 a = function (...args) { return A(b(...args)) }, b = C return function (...args) { return function (...args) { return A(b(...args)) }(C(...args)) } ==&gt; return function (...args) { ...args ==&gt; [C(...args)] return A(b(C(...args)) } // 第三轮 a = function (...args) { return function (...args) { return A(b(...args)) }(C(...args)) }, b = D return function (...args) { return function (...args) { return function (...args) { return A(b(...args)) }(C(...args)) }(D(...args)) } ==&gt; return function (...args) { ...args ==&gt; [D(...args)] return A(b(C(D(...args))) } // ............至数组最后一项之后结束循环 --&gt; // ===&gt; A(B(C(D(E(F(...args)))))) --&gt; (10) --&gt; A(B(C(D(E(F(10)))))) return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));}// compose(A, B, C)(10);console.log(compose(A, B, C)(10)); // --&gt; 10 总结compose 函数在函数式编程里很常见。这里redux的对 compose 实现很简单，理解起来却没有那么容易，主要还是因为对 Array.prototype.reduce 这个数组函数没有那么熟练，其次就是这种接受函数返回函数的写法，再配上箭头函数几个连续的 =&gt; ，让人容易看晕。不过只要按执行步骤慢慢的捋执行顺序，还是比较容易理解的。。嗝~","link":"/posts/83dcefb7/"},{"title":"redux-核心原理实现","text":"redux是什么 很多人认为redux必须要结合React使用，其实并不是的，Redux 是 JavaScript 状态容器，只要你的项目中使用到了状态，并且状态十分复杂，那么你就可以使用Redux管理你的项目状态，它可以使用在react中，也可以使用中在Vue中，当然也适用其他的框架。 redux 工作原理 首先我们找到最上面的 state 在 react 中 state 决定了视图（ui），state的变化就会调用React的 render（）方法，从而改变视图 用户通过一些事件（如点击按钮，移动鼠标）就会像reducer派发一个action reducer接收到action后就会去更新state store是包含了所有了state，可以把他看做所有状态的集合 redux的一些api及使用方法这里不再过多叙述 详情可以了解 redux 文档：redux 中文文档 redux 源码剖析, 丐版实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// redux : 精简源码，只写了核心原理export function createStore(reducer) { // 创建store状态 let state; // store事件池 let listeners = []; // 获取state状态信息 function getState() { // redux不允许直接更改state，但是源码中又没有做相应的处理 // 这里用JSON做一个简单的深克隆处理 return JSON.parse(JSON.stringify(state)); } // 派发提交 function dispatch(action) { state = reducer(state, action); // 每次dispatch以后，都要发布一下事件池 listeners.forEach(item =&gt; { if (typeof item === &quot;function&quot;) item(); }); } // 订阅 function subscribe(func) { // 在redux源码中并没有做事件池去重； 个人觉得要做一下去重 if (!listeners.includes(func)) listeners.push(func); // subscribe(): 会返回一个函数，用来从事件池中移除当前事件 (取消订阅) return function unSubscribe() { // 为防止数组塌陷问题，这里用filter替代splice移除数组项 listeners = listeners.filter(item =&gt; item !== func); } } // 初始化state，创建store时默认派发一次 dispatch({ // 初始派发的type值一定不要和项目中的type值有重复的；这里redux源码做了一个随机数截取处理转字符串所生成的一个尽可能不重复的type初始值 type: &quot;@@redux/INIT&quot; + Date.now() // 简单操作一下，其实也可以不传type }); return { getState, dispatch, subscribe }}// combineReducers: 合并reducerexport function combineReducers(reducers) { // 创建store初始化state。默认 = {} return function (state = {}, action) { let combineState = {}; for (let key in reducers) { if (!reducers.hasOwnProperty(key)) break; combineState[key] = reducers[key](state[key], action); } return combineState; // 最终state : { module1: {..}, module2: {..}, .....} // 初始化创建之后，以后的每一次执行dispatch，都会让每一个组件模块下的reducer执行，且会把state中对应组件名的对应数据传入reducer ==&gt; reducer(state.module, action) }} 这里只精简写了一下redux核心工作原理, 还有一些bindActionCreators、applyMiddleware、compose…..其他的api后续再详情探究一下 ~~嗝了","link":"/posts/a1c455e0/"}],"tags":[{"name":"CSS3","slug":"CSS3","link":"/tags/CSS3/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"HTML5","slug":"HTML5","link":"/tags/HTML5/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"library","slug":"library","link":"/tags/library/"},{"name":"镜头","slug":"镜头","link":"/tags/%E9%95%9C%E5%A4%B4/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"redux","slug":"redux","link":"/tags/redux/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"摄影","slug":"摄影","link":"/categories/%E6%91%84%E5%BD%B1/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"}],"pages":[{"title":"404","text":"404 body{background:#fff}div{width:1024px;height:320px;position:absolute;top:40%;left:50%;transform:translate(-50%,-50%)}","link":"/404.html"},{"title":"About Me","text":"这里是zhangone的个人空间站 ~ 故我所求，唯有真爱和自由 🎉关于本站最初建站的目的只是想用来记录一些工作学习的笔记。(也并不是记性很差，是“突发性健忘症晚期患者”🐶🐶)随着后来自己想要记录的东西也多了起来，开始愈发的折腾小破站。已经不是一个纯粹的技术博客了😄😄。目前对本站的规划：能够是一个记录学习、摄影、生活、及今后我可能想加入更多东西的个人空间站了。呃…总是想在自己的能力范围内尽可能的做到更好。 🌈关于我的关于我：00年，性别男，直男，钢铁直男。爱好女。是一个没啥优点也没缺陷，既能干饭也能干活，普普通通、简简单单的喜欢安静的人。目前职业是一名前端工程师。同样也喜欢一些其他有趣的技术语言和方向。 兴趣or爱好： 数码产品 摄影记录 日漫国漫 追剧：经典剧、喜剧、科幻、… 音乐：吉他、电钢 。（手残党） …… 保持热爱，美好的事物即将发生 📮联系方式 QQ: 1580646258 邮箱：zhangone233@126.com GitHub：https://github.com/zhangone233","link":"/about.html"},{"title":"fireworks","text":"烟花模拟器 加载中 正在装配烟花 设置 若想了解更多信息 请点击任意标签 烟花类型 烟花大小 画质 照亮天空 缩放 自动放烟花 同时放更多的烟花 隐藏控制按钮 全屏 保留烟花的火花 您的IP： document.write(returnCitySN[\"cip\"]) var mydate = new Date(); document.writeln(\"Copyright&nbsp;&copy;&nbsp;2021 - \" + mydate.getFullYear() + '&nbsp;碎念_NianAll&nbsp;Rights&nbsp;Reserved'); 关闭","link":"/fireworks.html"},{"title":"","text":"\"use strict\";console.clear();const IS_MOBILE=window.innerWidthisRunning(e)&&soundEnabledSelector(e),qualitySelector=()=>+store.state.config.quality,shellNameSelector=()=>store.state.config.shell,shellSizeSelector=()=>+store.state.config.size,finaleSelector=()=>store.state.config.finale,skyLightingSelector=()=>+store.state.config.skyLighting,scaleFactorSelector=()=>store.state.config.scaleFactor,helpContent={shellType:{header:\"烟花类型\",body:\"你要放的烟花的类型，选择“随机（Random）”可以获得非常好的体验！\"},shellSize:{header:\"烟花大小\",body:\"烟花越大绽放范围就越大，但是烟花越大，设备所需的性能也会增多，大的烟花可能导致你的设备卡顿。\"},quality:{header:\"画质\",body:\"如果动画运行不流畅，你可以试试降低画质。画质越高，烟花绽放后的火花数量就越多，但高画质可能导致你的设备卡顿。\"},skyLighting:{header:\"照亮天空\",body:\"烟花爆炸时，背景会被照亮。如果你的屏幕看起来太亮了，可以把它改成“暗”或者“不”。\"},scaleFactor:{header:\"缩放\",body:\"使你与烟花离得更近或更远。对于较大的烟花，你可以选择更小的缩放值，尤其是在手机或平板电脑上。\"},autoLaunch:{header:\"自动放烟花\",body:\"开启后你就可以坐在你的设备屏幕前面欣赏烟花了，你也可以关闭它，但关闭后你就只能通过点击屏幕的方式来放烟花。\"},finaleMode:{header:\"同时放更多的烟花\",body:\"可以在同一时间自动放出更多的烟花（但需要开启先开启“自动放烟花”）。\"},hideControls:{header:\"隐藏控制按钮\",body:\"隐藏屏幕顶部的按钮。如果你要截图，或者需要一个无缝的体验，你就可以将按钮隐藏，隐藏按钮后你仍然可以在右上角打开设置。\"},fullscreen:{header:\"全屏\",body:\"切换至全屏模式\"},longExposure:{header:\"保留烟花的火花\",body:\"可以保留烟花留下的火花\"}},nodeKeyToHelpKey={shellTypeLabel:\"shellType\",shellSizeLabel:\"shellSize\",qualityLabel:\"quality\",skyLightingLabel:\"skyLighting\",scaleFactorLabel:\"scaleFactor\",autoLaunchLabel:\"autoLaunch\",finaleModeLabel:\"finaleMode\",hideControlsLabel:\"hideControls\",fullscreenLabel:\"fullscreen\",longExposureLabel:\"longExposure\"},appNodes={stageContainer:\".stage-container\",canvasContainer:\".canvas-container\",controls:\".controls\",menu:\".menu\",menuInnerWrap:\".menu__inner-wrap\",pauseBtn:\".pause-btn\",pauseBtnSVG:\".pause-btn use\",soundBtn:\".sound-btn\",soundBtnSVG:\".sound-btn use\",shellType:\".shell-type\",shellTypeLabel:\".shell-type-label\",shellSize:\".shell-size\",shellSizeLabel:\".shell-size-label\",quality:\".quality-ui\",qualityLabel:\".quality-ui-label\",skyLighting:\".sky-lighting\",skyLightingLabel:\".sky-lighting-label\",scaleFactor:\".scaleFactor\",scaleFactorLabel:\".scaleFactor-label\",autoLaunch:\".auto-launch\",autoLaunchLabel:\".auto-launch-label\",finaleModeFormOption:\".form-option--finale-mode\",finaleMode:\".finale-mode\",finaleModeLabel:\".finale-mode-label\",hideControls:\".hide-controls\",hideControlsLabel:\".hide-controls-label\",fullscreenFormOption:\".form-option--fullscreen\",fullscreen:\".fullscreen\",fullscreenLabel:\".fullscreen-label\",longExposure:\".long-exposure\",longExposureLabel:\".long-exposure-label\",helpModal:\".help-modal\",helpModalOverlay:\".help-modal__overlay\",helpModalHeader:\".help-modal__header\",helpModalBody:\".help-modal__body\",helpModalCloseBtn:\".help-modal__close-btn\"};function renderApp(e){var t=\"#icon-\"+(e.paused?\"play\":\"pause\"),a=\"#icon-sound-\"+(soundEnabledSelector()?\"on\":\"off\");appNodes.pauseBtnSVG.setAttribute(\"href\",t),appNodes.pauseBtnSVG.setAttribute(\"xlink:href\",t),appNodes.soundBtnSVG.setAttribute(\"href\",a),appNodes.soundBtnSVG.setAttribute(\"xlink:href\",a),appNodes.controls.classList.toggle(\"hide\",e.menuOpen||e.config.hideControls),appNodes.canvasContainer.classList.toggle(\"blur\",e.menuOpen),appNodes.menu.classList.toggle(\"hide\",!e.menuOpen),appNodes.finaleModeFormOption.style.opacity=e.config.autoLaunch?1:.32,appNodes.quality.value=e.config.quality,appNodes.shellType.value=e.config.shell,appNodes.shellSize.value=e.config.size,appNodes.autoLaunch.checked=e.config.autoLaunch,appNodes.finaleMode.checked=e.config.finale,appNodes.skyLighting.value=e.config.skyLighting,appNodes.hideControls.checked=e.config.hideControls,appNodes.fullscreen.checked=e.fullscreen,appNodes.longExposure.checked=e.config.longExposure,appNodes.scaleFactor.value=e.config.scaleFactor.toFixed(2),appNodes.menuInnerWrap.style.opacity=e.openHelpTopic?.12:1,appNodes.helpModal.classList.toggle(\"active\",!!e.openHelpTopic),e.openHelpTopic&&({header:t,body:a}=helpContent[e.openHelpTopic],appNodes.helpModalHeader.textContent=t,appNodes.helpModalBody.textContent=a)}function handleStateChange(e,t){e=canPlaySoundSelector(e);e!==canPlaySoundSelector(t)&&(e?soundManager.resumeAll():soundManager.pauseAll())}function getConfigFromDOM(){return{quality:appNodes.quality.value,shell:appNodes.shellType.value,size:appNodes.shellSize.value,autoLaunch:appNodes.autoLaunch.checked,finale:appNodes.finaleMode.checked,skyLighting:appNodes.skyLighting.value,longExposure:appNodes.longExposure.checked,hideControls:appNodes.hideControls.checked,scaleFactor:parseFloat(appNodes.scaleFactor.value)}}Object.keys(appNodes).forEach(e=>{appNodes[e]=document.querySelector(appNodes[e])}),fullscreenEnabled()||appNodes.fullscreenFormOption.classList.add(\"remove\"),store.subscribe(renderApp),store.subscribe(handleStateChange);const updateConfigNoEvent=()=>updateConfig(),COLOR_NAMES=(appNodes.quality.addEventListener(\"input\",updateConfigNoEvent),appNodes.shellType.addEventListener(\"input\",updateConfigNoEvent),appNodes.shellSize.addEventListener(\"input\",updateConfigNoEvent),appNodes.autoLaunch.addEventListener(\"click\",()=>setTimeout(updateConfig,0)),appNodes.finaleMode.addEventListener(\"click\",()=>setTimeout(updateConfig,0)),appNodes.skyLighting.addEventListener(\"input\",updateConfigNoEvent),appNodes.longExposure.addEventListener(\"click\",()=>setTimeout(updateConfig,0)),appNodes.hideControls.addEventListener(\"click\",()=>setTimeout(updateConfig,0)),appNodes.fullscreen.addEventListener(\"click\",()=>setTimeout(toggleFullscreen,0)),appNodes.scaleFactor.addEventListener(\"input\",()=>{updateConfig(),handleResize()}),Object.keys(nodeKeyToHelpKey).forEach(e=>{const t=nodeKeyToHelpKey[e];appNodes[e].addEventListener(\"click\",()=>{store.setState({openHelpTopic:t})})}),appNodes.helpModalCloseBtn.addEventListener(\"click\",()=>{store.setState({openHelpTopic:null})}),appNodes.helpModalOverlay.addEventListener(\"click\",()=>{store.setState({openHelpTopic:null})}),Object.keys(COLOR)),COLOR_CODES=COLOR_NAMES.map(e=>COLOR[e]),COLOR_CODES_W_INVIS=[...COLOR_CODES,INVISIBLE],COLOR_CODE_INDEXES=COLOR_CODES_W_INVIS.reduce((e,t,a)=>(e[t]=a,e),{}),COLOR_TUPLES={};function randomColorSimple(){return COLOR_CODES[Math.random()*COLOR_CODES.length|0]}COLOR_CODES.forEach(e=>{COLOR_TUPLES[e]={r:parseInt(e.substr(1,2),16),g:parseInt(e.substr(3,2),16),b:parseInt(e.substr(5,2),16)}});let lastColor;function randomColor(e){var t=e&&e.notSame,a=e&&e.notColor,e=e&&e.limitWhite;let o=randomColorSimple();if(e&&o===COLOR.White&&Math.random(){this.ctx.resume()},250)},_lastSmallBurstTime:0,playSound(e,t=1){if(t=MyMath.clamp(t,0,1),canPlaySoundSelector()&&!(simSpeed","link":"/fireworks/js/script.js"}]}